[{"categories":["笔记"],"content":"学习Transformer的基本原理和应用","date":"2025/04/15","objectID":"/transformer/","tags":["人工智能"],"title":"理解Transformer","uri":"/transformer/"},{"categories":["笔记"],"content":"理解自注意力机制 结合up主王木头的讲解1，在经过词向量嵌入操作后，模型输入的每个token都是拥有了基本语义的向量，可以客观表示自身。注意力机制则用来计算每个token与其他token之间的关系，以便在生成输出时考虑上下文信息。 Attention基本计算公式为： $$ Attention(Q, K, V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})V $$ 其中，$Q$、$K$、$V$分别表示查询向量都出自于输入的token，$d_k$表示向量的维度。 在进行计算时，首先对$Q$和$K$进行内积运算，得到了一个查询向量（token）和所有向量（token）的关系矩阵。通过softmax函数将其转化为权重分布，归一化后得到的权重分布表示了每个token对当前token的影响程度。从而得到对应的值向量$V$的加权和，用来计算最终的输出。 从另一个角度来看，$Q$、$K$、$V$分别表示查询、键、值。用$Q$和$K$计算得到最相关的token，根据相关度与对应的$V$进行加权求和，最终得到当前token的表示。$Q$表示当前正在关注的token，即想找的相关信息；$K$表示其他token的特征，用于显示上下文；$V$表示其他token实际提供的信息。 ","date":"2025/04/15","objectID":"/transformer/:1:0","tags":["人工智能"],"title":"理解Transformer","uri":"/transformer/"},{"categories":["笔记"],"content":"参考资料 https://www.bilibili.com/video/BV1XH4y1T76e/ “B站: 王木头讲解” ↩︎ ","date":"2025/04/15","objectID":"/transformer/:2:0","tags":["人工智能"],"title":"理解Transformer","uri":"/transformer/"},{"categories":["笔记"],"content":"记录操作系统学习的美妙时刻。","date":"2025/04/12","objectID":"/operation-system/","tags":["C++","算法"],"title":"操作系统学习","uri":"/operation-system/"},{"categories":["笔记"],"content":"死锁问题 死锁是指，多个进程在执行过程中，因争夺资源而造成的一种互相等待的现象。 死锁的必要条件有： 互斥条件：资源不能被多个进程共享。 占有且等待条件：一个进程至少持有一个资源，并等待其他资源。 不剥夺条件：已获得的资源在未使用完之前，不能被其他进程抢占。 环路等待条件：存在一个进程的集合，使得每个进程都在等待其他进程持有的资源。 ","date":"2025/04/12","objectID":"/operation-system/:1:0","tags":["C++","算法"],"title":"操作系统学习","uri":"/operation-system/"},{"categories":["笔记"],"content":"死锁检测 死锁检测是指，系统定期检查进程的状态，判断是否存在死锁。 死锁检测算法通常使用资源分配图（Resource Allocation Graph，RAG）来表示进程和资源之间的关系。通过检测图中是否存在环路来判断是否发生死锁。 环路判断可通过DFS或拓扑排序等算法实现。 DFS，从任意一个节点开始，优先向下一个节点遍历，直到无法继续遍历为止。若在遍历过程中发现已经访问过的节点，则说明存在环路。 // DFS判断环路（递归） bool hasCycle(int u, vector\u003cvector\u003cint\u003e\u003e\u0026 graph, vector\u003cint\u003e\u0026 visited) { visited[u] = 1; // 标记为正在访问 for (int v : graph[u]) { if (visited[v] == 1) { return true; // 回到正在访问中的点，发现环 } if (visited[v] == 0 \u0026\u0026 hasCycle(v, graph, visited)) { return true; } } visited[u] = 2; // 标记访问完成 return false; } bool detectDeadlock(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { vector\u003cint\u003e visited(n, 0); for (int i = 0; i \u003c n; ++i) { if (visited[i] == 0) { if (hasCycle(i, graph, visited)) return true; } } return false; // 没有环，没死锁 } 拓扑排序，从入度为0的节点开始，依次删除该节点及其出边，直到所有节点都被删除。若最终发现还有节点未被删除，则说明存在环路。 // 拓扑排序判断环路 vector\u003cint\u003e detectDeadlock(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { vector\u003cint\u003e indegree(n, 0); // 入度 for (int u = 0; u \u003c n; ++u) { for (int v : graph[u]) { indegree[v]++; } } queue\u003cint\u003e q; for (int i = 0; i \u003c n; ++i) { if (indegree[i] == 0) q.push(i); // 初始入度为0的点 } int resultSize = 0; while (!q.empty()) { int u = q.front(); q.pop(); resultSize++; for (int v : graph[u]) { if (--indegree[v] == 0) { q.push(v); } } } // 检查是否有环 return resultSize != n; // 有环返回true } ","date":"2025/04/12","objectID":"/operation-system/:1:1","tags":["C++","算法"],"title":"操作系统学习","uri":"/operation-system/"},{"categories":["笔记"],"content":"死锁避免 死锁避免是指，系统在资源分配时，采取一些措施来避免死锁的发生。常用的方法如Dijkstra提出的银行家算法（Banker’s Algorithm）。通过预判资源分配后的系统状态是否安全，来决定是否允许某进程申请资源。 银行家算法的实现主要有两点： 自愿请求处理： 判断请求是否超出该进程的最大需求。 判断请求是否超出系统的可用资源。 资源预分配，并系统状态是否安全。 安全，分配成功。 不安全，回滚做出的资源预分配。 安全性检查：判断当前系统状态是否安全，即所有进程都能顺利完成。 循环判断每个进程是否能完成，若能完成，则将其释放的资源加入可用资源中。 若所有进程都能完成，则系统状态安全。 ","date":"2025/04/12","objectID":"/operation-system/:1:2","tags":["C++","算法"],"title":"操作系统学习","uri":"/operation-system/"},{"categories":["笔记"],"content":"记录数据结构学习的奇妙旅程。","date":"2025/04/11","objectID":"/data-structure/","tags":["C++","算法"],"title":"数据结构学习","uri":"/data-structure/"},{"categories":["笔记"],"content":"栈的实现 在IO Wiki上看到一个用数组实现栈的例子，真是被妙到了，值得记录一下。 int stack[10] = {0}; // 入栈 stack[++*stack] = 18; stack[++*stack] = 22; cout \u003c\u003c \"test\" \u003c\u003c endl; for (auto n: stack) cout \u003c\u003c n \u003c\u003c \" \"; // 出栈 int num = stack[*stack--]; // 清空 *stack = 0; 使用数组的首元素作为栈顶指针，这样就可以用*stack来表示栈顶元素的下标。栈顶元素的值为0，表示栈为空。当然，这里的清空是假性清空并未真正删除存储值，但并不影响下次入栈操作；还需要注意的是，应当加入适当的边界检查，避免栈溢出，如超出数组长度、首元素减至小于0。 ","date":"2025/04/11","objectID":"/data-structure/:1:0","tags":["C++","算法"],"title":"数据结构学习","uri":"/data-structure/"},{"categories":["笔记"],"content":"队列的实现 队列中，使用双栈实现的方式也很妙。 使用两个栈in和out，in栈用于入队，out栈用于出队。出队时，若out为空，则将in栈中的元素全部倒入out栈中，再进行出队。 ","date":"2025/04/11","objectID":"/data-structure/:2:0","tags":["C++","算法"],"title":"数据结构学习","uri":"/data-structure/"},{"categories":["笔记"],"content":"记录列表寻找子集的求解方法。","date":"2025/04/06","objectID":"/find-subsets/","tags":["python","算法"],"title":"寻找子集问题","uri":"/find-subsets/"},{"categories":["笔记"],"content":"已知一个列表，求出它的所有子集。 ","date":"2025/04/06","objectID":"/find-subsets/:0:0","tags":["python","算法"],"title":"寻找子集问题","uri":"/find-subsets/"},{"categories":["笔记"],"content":"递归求解 以最小问题，即空列表作为递归的终止条件。每次进行递归求解时减少列表规模，直到列表为空，如每次去掉列表的第一个元素。通过逐步剔除首元素减小列表数量，在达到递归终止条件时，返回一个包含空列表的列表。然后再将首元素与返回的列表进行组合，形成新的子集列表。 def find_subsets(nums): if len(nums) == 0: return [[]] rest_sub = find_subsets(nums[1:]) sub = rest_sub + [[nums[0]]+sub for sub in rest_sub] return sub ","date":"2025/04/06","objectID":"/find-subsets/:1:0","tags":["python","算法"],"title":"寻找子集问题","uri":"/find-subsets/"},{"categories":["笔记"],"content":"位运算求解 实际上，一个长度为$n$的列表有$2^n$个子集。对于每一个子集，可以用一个长度为$n$的二进制数来表示，每一个二进制位表示列表中对应位置的元素是否在子集中。如，列表[1, 2, 3]的某个子集为[1, 3]，可以用二进制数101表示；子集[3]可以用001表示。 def find_subsets(nums): n = len(nums) subsets = [] for i in range(2\u003c\u003cn): subsets.append([nums[j] for j in range(n) if i\u003e\u003ej \u0026 1]) return subsets","date":"2025/04/06","objectID":"/find-subsets/:2:0","tags":["python","算法"],"title":"寻找子集问题","uri":"/find-subsets/"},{"categories":["笔记"],"content":"把现在还记得的pdd二面问题都记下来","date":"2025/04/03","objectID":"/pdd-2-interview/","tags":["人工智能"],"title":"pdd算法工程师二面","uri":"/pdd-2-interview/"},{"categories":["笔记"],"content":" 自我介绍 介绍一下印象最深的项目 项目中遇到的最大困难，如何解决的 激活函数的作用和常见的激活函数，该如何做选择 softmax和sigmoid函数的计算公式 attention的计算公式，$Attention(Q,K,V,d_k)$ 矩阵乘法的乘法计算次数 算法题，将一个正整数分为多个正整数，求出它们的乘积最大值 对pdd公司的了解，如工作强度、组织架构等 看你之前做了这么多开发，现在为什么选择算法岗 ","date":"2025/04/03","objectID":"/pdd-2-interview/:0:0","tags":["人工智能"],"title":"pdd算法工程师二面","uri":"/pdd-2-interview/"},{"categories":["笔记"],"content":"备考深度学习算法工程师面试题","date":"2025/04/03","objectID":"/dl-engineer/","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"题目来自B站视频，针对p1和p2的大部分面试题，结合ChatGPT进行解析和记录。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:0","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"如何解决正负样本不均衡？ 样本不均衡是指在分类问题中，不同类别的样本数量差异较大，这会导致模型偏向于数量较多的类别。 常见的解决方法包括： 采样，对样本进行过采样或欠采样，如对少数类进行重复采样，或对多数类进行随机删除。 加权损失函数，在损失函数中对少数类样本赋予更高的权重，以平衡不同类别的影响，如focal loss。 数据增强，对少数类样本进行数据增强，如旋转、平移、缩放等操作，增加样本数量。 评价指标，使用适合不均衡数据集的评价指标，如F1-score、AUC等，而不是简单的准确率。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:1","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"评价指标 混淆矩阵：TP、TN、FP、FN，其中T和F分别表示真和假，是对预测结果的评价，P和N分别表示正和负/阳和阴，表示预测结果。如TP为真正例，表示预测为正，预测正确，实际上也为正；FN为假负例，预测为负，预测错误，实际上是正。特别提醒，一般情况下认为，FP是误报，FN是漏检。 准确性 $Accuracy = \\frac{TP+TN}{TP+TN+FP+FN}$，反映预测正确所占的比例。 精确率 $Precision = \\frac{TP}{TP+FP}$，反映预测为正的样本中，实际为正的比例。 召回率 $Recall = \\frac{TP}{TP+FN}$，反映模型对实际为正类的样本识别的准确性。 F1-score $F1 = \\frac{2 \\cdot Precision \\cdot Recall}{Precision + Recall}$，综合考虑精确率和召回率的指标。 ROC曲线：以假正率为横坐标，真正率为纵坐标，曲线下面积AUC表示模型的分类能力。 PR曲线：以精确率为横坐标，召回率为纵坐标，曲线下面积AP表示模型的分类能力，适用于极度不均衡的数据。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:2","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"损失函数 MAE和MSE 平均绝对误差，MAE，表示预测值与真实值之间的绝对差的平均值，不易被极端值影响，适用于异常值较多的情况。 绝对误差，对大误差更敏感，适用于需要关注大误差的任务，如金融、医疗预测。 l1 loss、l2 loss和smooth l1 loss 实际上，l1 loss、l2 loss分别是MAE和MSE的另一种表示方式，相比之下少了个平均。 smooth l1 loss是l1 loss和l2 loss的结合，误差小时使用l2 loss，避免梯度不稳定；误差大时使用l1 loss，避免异常值的影响。 $$ L_{smooth} = \\begin{cases} \\frac{1}{2}x^2 \u0026 \\text{if } |x| \u003c 1 \\ |x| - \\frac{1}{2} \u0026 \\text{otherwise} \\end{cases} $$ focal loss 传统交叉熵损失函数在处理正负样本不均衡时，容易导致模型对多数类样本的过拟合，而忽略少数类样本。 $$ CE(p_t) = -\\log(p_t) $$ focal loss通过引入调节因子$\\gamma$，使得模型在训练时更加关注难分类的样本，从而提高模型对少数类样本的识别能力。 $$ FL(p_t) = -\\alpha_t(1-p_t)^\\gamma \\log(p_t) $$ 其中，$p_t$为预测概率，$\\alpha_t$为平衡因子，用于调整正负样本的重要性，适用于不均衡数据集，$\\gamma$为调节因子，控制难易样本的影响程度，样本容易分类时，$FL$的值会减小，反之则增大。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:3","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"卷积的特点 局部连接，卷积核只与输入数据的局部区域进行计算，减少了参数数量，提高了计算效率。 权值共享，卷积核在输入数据的不同位置共享相同的权值，减少了模型的复杂度，提高了模型的泛化能力。 下采样，通过步长和池化操作，减少了输入数据的尺寸，提高了计算效率。 平移不变性，卷积操作对输入数据的平移具有不变性，即输入数据的平移不会影响卷积结果，增强了模型对输入数据的鲁棒性。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:4","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"关于计算 参数量和计算量 需要注意的是，参数量和计算量不是一回事，参数指模型中可训练的参数总数，通常指权重和偏置，它决定了模型的大小；计算量指在推理或训练时所需的计算量，通常指乘法和加法的次数，决定了模型的运行速度。 用卷积层举例，参数量=每个卷积核的参数$\\times$卷积核的数量；计算量=每个像素点的计算量$\\times$输出特征图的大小。 假设有一个3x3的卷积核，输入通道为64，输出通道为128，输入特征图大小为224x224，步长为1，无填充，输出特征图大小仍为224x224。 参数量=(3x3x64+1)x128=73792 计算量=2x(3x3x64)x224x224x128=7.4G 卷积和池化后的patch计算 再来说一下，经过卷积层后的patch计算。 假设输入大小为$H_{in} \\times W_{in}$，卷积核大小为$K_h \\times K_w$，步长为$S$，填充为$P$，输出大小为$H_{out} \\times W_{out}$。卷积输出大小计算公式如下： $$ H_{out} = \\frac{H_{in} - K_h + 2P}{S} + 1 \\ W_{out} = \\frac{W_{in} - K_w + 2P}{S} + 1 $$ 假设池化窗口大小为$K_h \\times K_w$，步长为$S$，池化输出大小计算公式如下： $$ H_{out} = \\frac{H_{in} - K_h}{S} + 1 \\ W_{out} = \\frac{W_{in} - K_w}{S} + 1 $$ 感受野的计算 感受野是指卷积神经网络中某一层的神经元所能感知到的输入数据的区域大小。感受野越大，模型对输入数据的上下文信息捕捉能力越强。感受野的计算公式如下： $$R_{out} = R_{in} + (K - 1) \\times \\prod_{i=1}^{j-1} S_i$$ 其中，$R_{out}$为输出层的感受野，$R_{in}$为输入层的感受野，$K$为卷积核大小，$S_i$为步长，$j$为前几层的层数。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:5","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"BN 批量归一化（Batch Normalization）是一种加速深度神经网络训练的技术，通过对每一层的输入进行标准化，使其均值为0，方差为1，从而加快收敛速度，减小对初始化的依赖。 在batch维度上计算均值和方差，进行标准化。 通过可学习的参数$\\gamma$和$\\beta$进行缩放和平移，恢复模型的表达能力。 在推理阶段，使用整个训练集的均值和方差进行标准化，避免了batch size对模型性能的影响。 BN通常用在激活函数之前，避免了激活函数的非线性影响。 BN层的参数量为$2 \\times C$，其中$C$为通道数。 训练时为什么要分batch 内存限制，一次性处理整个数据集可能会导致内存不足，分batch可以有效利用内存。 随机性，分batch可以引入随机性，增加模型的泛化能力，避免过拟合。 并行计算，分batch可以利用GPU的并行计算能力，提高训练速度。 内部协方差偏移，分batch可以减少内部协方差偏移，提高模型的收敛速度。 优缺点 优点： 使网络对初始化不敏感。 均值和方差引入了一定的噪声类似dropout，具有一定的正则化效果，减少过拟合。 解决梯度消失和梯度爆炸问题，训练更稳定。 减少内部协方差偏移，加快收敛速度。 缺点： BN对batch size敏感，batch size过小会导致均值和方差不稳定，影响模型性能。 额外的计算开销，增加了训练时间和内存消耗。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:6","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"优化器 通过梯度下降法及其变种，利用反向传播计算出梯度来更新网络的参数。 SGD：随机梯度下降，计算每个样本的梯度，更新参数。震荡，收敛慢；容易陷入局部最优。 Momentum：在SGD的基础上，引入动量项，考虑历史梯度，减少震荡，加快收敛速度。仍可能陷入局部最优。 AdaGrad：自适应学习率，针对每个参数计算不同的学习率，适用于稀疏数据。学习率会逐渐减小，可能导致收敛过慢。 RMSProp：对AdaGrad的改进，使用指数衰减平均来计算学习率，避免学习率过小的问题。适用于非平稳目标。依赖于超参数的选择。 Adam：结合了Momentum和RMSProp的优点，使用动量和自适应学习率，适用于大规模数据和高维参数。计算复杂度较高，依赖于超参数的选择。其中，一阶矩（期望）用于平滑梯度更新方向，加速收敛；二阶矩（方差）用于自适应学习率，避免震荡。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:7","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"激活函数 激活函数用于引入非线性特性，使得神经网络能够学习复杂的函数映射关系。 sigmoid函数：$f(x) = \\frac{1}{1 + e^{-x}}$，输出范围在(0, 1)，适用于二分类问题。在极端值处容易导致梯度消失；输出范围均值不为0，影响梯度流动；计算涉及指数，计算成本高。 tanh函数：$f(x) = \\frac{e^x - e^{-x}}{e^x + e^{-x}}$，输出范围在(-1, 1)，适用于二分类问题。零均值梯度流动更稳定；梯度消失仍存在；计算涉及指数，计算成本高。 ReLU函数：$f(x) = \\max(0, x)$，输出范围在[0, +∞)。计算简单，收敛速度快；负半轴梯度为0，可能导致神经元死亡；不能用于rnn等依赖梯度流动的网络，可能导致梯度爆炸。 Leaky ReLU函数：$f(x) = \\max(\\alpha x, x)$.解决了ReLU的神经元死亡问题；计算简单，收敛速度快；仍然存在梯度爆炸问题。 softmax函数：$f(x) = \\frac{e^{x_i}}{\\sum_{j=1}^{n} e^{x_j}}$，用于多分类问题，输出范围在(0, 1)，且和为1。计算涉及指数，计算成本高；对异常值敏感，可能导致梯度爆炸。 均值为0的影响 非线形特性，在接近0处有更大的梯度，避免了梯度消失问题。 梯度传播中的偏移，可能导致梯度爆炸或消失，影响模型的收敛速度。 解决方案： 使用ReLU等激活函数代替sigmoid和tanh。 使用BN层进行标准化，保持均值为0，方差为1。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:8","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"强化学习ppo PPO是一种更新策略的方法。 ppo的损失分为三部分： 策略损失，使用当前策略和旧策略的比值来计算重要性采样权重，然后通过clip函数限制比值的范围，从而确定策略损失； 值函数损失，使用值网络估计状态的价值，通过均方误差计算损失； 熵损失，动作越不确定熵值越大，增加策略的随机性，避免过拟合。 对于一批数据重复多次更新参数。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:9","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"batch size对训练的影响 小，训练时间长，梯度变化大，导致参数更新方向不稳定，但有助于跳出局部最优解，泛化能力更强。 可以通过提高学习率或GroupNorm来缓解。 大，梯度平滑，训练稳定，需要更多显存。可以通过降低学习率或分批进行反向传播缓解。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:10","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"非极大值抑制NMS 主要用于目标检测中，去除重叠度较高的候选框。 对于检测器可能输出的多个重叠框（IOU很高），NMS通过置信度排序+IOU阈值抑制低质量框，达到保留最优框的效果。 选择置信度最高的框作为基准框。 计算基准框与其他框的IOU，去除IOU大于设定阈值的框。 重复步骤1和2，直到处理完所有框。 高效去重，计算简单；若多个目标位置相近，容易误删；所有框统一处理，不能按照不能类别处理。 改进 Soft-NMS：不直接删除重叠框，而是根据IOU值调整置信度，保留重叠框，降低置信度。 Multi-Class NMS：针对多类别目标检测，分别计算每个类别的NMS，避免误删其他类别的框。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:11","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"过拟合 过拟合是指模型在训练集上表现良好，但在测试集上表现不佳，泛化能力差。解决方法如下： 数据增强，通过旋转、平移、缩放等方式增加训练数据的多样性。 正则化，如L1、L2正则化，限制模型参数的大小，防止过拟合。 Dropout，在训练过程中随机丢弃一部分神经元，减少模型的复杂度。 早停法，在验证集上监控模型性能，当性能不再提升时停止训练。 交叉验证，将数据集划分为多个子集，轮流使用其中一个子集作为验证集，其余作为训练集，评估模型的泛化能力。 其中L1正则会促使一些权重变为0，使得模型稀疏化，适用于特征选择和高纬数据场景；L2正则会促使权重变小，使训练更稳定，适用于深度神经网络或回归任务。 Elastic Net结合了L1和L2正则化的优点，适用于高维数据和特征选择。 ","date":"2025/04/03","objectID":"/dl-engineer/:0:12","tags":["人工智能"],"title":"备战深度学习算法工程师","uri":"/dl-engineer/"},{"categories":["笔记"],"content":"LeetCode.70.爬楼梯，记录爬楼问题求解的分析过程。","date":"2025/03/31","objectID":"/climb/","tags":["python","算法"],"title":"爬楼问题笔记","uri":"/climb/"},{"categories":["笔记"],"content":"LeetCode.70.爬楼梯被列为一道简单题，巧合下这几天又遇到了这道题的变种，于是又回头研究了一番。 先简述一下问题，已知有$n$个台阶，每次可爬1或2个台阶，求有多少种不同的爬楼方式。 ","date":"2025/03/31","objectID":"/climb/:0:0","tags":["python","算法"],"title":"爬楼问题笔记","uri":"/climb/"},{"categories":["笔记"],"content":"递归求解 在确定问题终止节点后，可以使用递归算法求解。当还剩下0步时，返回计数1，即该方案已经到达终点；剩余多步则继续递归；小于0步则返回0，即无法到达终点。 def climb(n: int) -\u003e int: if n \u003c 0: return 0 elif n == 0: return 1 else: return climb(n-1) + climb(n-2) ","date":"2025/03/31","objectID":"/climb/:1:0","tags":["python","算法"],"title":"爬楼问题笔记","uri":"/climb/"},{"categories":["笔记"],"content":"记忆优化 通过增加记忆减少重复计算。虽然时间复杂度并未发生变化，但避免了数值的重复计算，极大提升了效率。 def climb(n: int) -\u003e int: memo = {} def step(n: int) -\u003e int: if n in memo.keys(): return memo[n] if n \u003c 0: return 0 elif n == 0: return 1 else: cnt = step(n-1) + step(n-2) memo[n] = cnt return cnt return step(n) ","date":"2025/03/31","objectID":"/climb/:2:0","tags":["python","算法"],"title":"爬楼问题笔记","uri":"/climb/"},{"categories":["笔记"],"content":"递推优化 当$n$较大时，递归算法会导致栈溢出，无法求解。这里尝试通过分析，找到新的求解关系。 不难看出递归求解$f(n)$时，实际计算了$f(n-1)$和$f(n-2)$，即每一项的值可以通过前两项的值求得，这看起来就很像是斐波那契数列。 def climb(n: int) -\u003e int: a, b = 1, 2 for _ in range(n-1): a, b = b, a+b return a ","date":"2025/03/31","objectID":"/climb/:3:0","tags":["python","算法"],"title":"爬楼问题笔记","uri":"/climb/"},{"categories":["笔记"],"content":"问题推广 现在，对原有问题进一步推广，每次可爬1、2、…、m个台阶，求有多少种不同的爬楼方式。 今天翻了翻LeetCode，发现已经有大佬提出过这个推广问题了。 相比每次爬1或2个台阶，此时每一步有$m$种选择。结合上面的递推分析，我们可以大胆猜测，此时$f(n)$的求解依赖前$m项的值。 def climb(n: int, m: int) -\u003e int: cnt = [0] * m cnt[0] = 1 for i in range(1, m): cnt[i] = sum(cnt[:i]) + 1 if n \u003c m: return cnt[n-1] for i in range(m, n+1): cnt[i % m] = sum(cnt) return cnt[(n-1) % m] 为了节约空间，可以循环使用一个长度为$m$的数组，存储前$m$项的值。在求解$f(n)$前，需要先计算出$f(1)$到$f(m)$的值。 ","date":"2025/03/31","objectID":"/climb/:4:0","tags":["python","算法"],"title":"爬楼问题笔记","uri":"/climb/"},{"categories":["笔记"],"content":"总结 这是一个考察动态规划、递归和递推分析的问题，重点在于分析，还是挺有意思的。 ","date":"2025/03/31","objectID":"/climb/:5:0","tags":["python","算法"],"title":"爬楼问题笔记","uri":"/climb/"},{"categories":["笔记"],"content":"最近重装win10系统，导致开机无法找到之前的Ubuntu引导，无法进入Ubuntu系统。","date":"2024/03/21","objectID":"/ubuntu-boot-repair/","tags":["linux"],"title":"修复Ubuntu引导问题","uri":"/ubuntu-boot-repair/"},{"categories":["笔记"],"content":"这两天又在折腾系统，没想到把Ubuntu的引导给搞坏了，导致开机无法找到之前的Ubuntu引导，无法进入Ubuntu系统。 在网上各种资料都没有解决我的问题，最后在csdn上找到了一个repair的方案1。 ","date":"2024/03/21","objectID":"/ubuntu-boot-repair/:0:0","tags":["linux"],"title":"修复Ubuntu引导问题","uri":"/ubuntu-boot-repair/"},{"categories":["笔记"],"content":"准备工作 与安装Ubuntu系统的准备工作一样，将系统镜像烧录到U盘里，这里就不赘述了； 进入系统安装引导后，依然选择第一项try or install ubuntu； 进入系统后，选择左侧的try ubuntu； CtrlAltT打开终端，输入以下命令，安装boot-repair工具； sudo add-apt-repository ppa:yannubuntu/boot-repair sudo apt-get update sudo apt-get install -y boot-repair 运行boot-repair工具，选择Recommended repair，等待工具自动修复引导问题； 弹出Boot successfully repaired提示后，重启电脑，即可看到引导界面，选择Ubuntu即可进入系统。 CSDN: ubuntu启动盘修复grub引导 ↩︎ ","date":"2024/03/21","objectID":"/ubuntu-boot-repair/:1:0","tags":["linux"],"title":"修复Ubuntu引导问题","uri":"/ubuntu-boot-repair/"},{"categories":["笔记"],"content":"Clash for Linux/Ubuntu的使用说明，包含下载地址及详细配置过程。","date":"2024/03/20","objectID":"/clash-for-ubuntu/","tags":["linux"],"title":"Clash for Linux/Ubuntu的使用说明","uri":"/clash-for-ubuntu/"},{"categories":["笔记"],"content":"Clash for Linux ","date":"2024/03/20","objectID":"/clash-for-ubuntu/:0:0","tags":["linux"],"title":"Clash for Linux/Ubuntu的使用说明","uri":"/clash-for-ubuntu/"},{"categories":["笔记"],"content":"应用概述 Clash是一款用Go语言开发，可以在Linux/MacOS/Windows等多平台使用的代理工具，配置也非常简单（特别是在Windows平台），支持ss/v*2ray（不支持ssr），支持规则分流（类似于 Surge 的配置）。 之前之前使用的Dreamacro/clash项目，作者已经跑路了。好在这次重装系统又找到了一个备份版本。 ","date":"2024/03/20","objectID":"/clash-for-ubuntu/:1:0","tags":["linux"],"title":"Clash for Linux/Ubuntu的使用说明","uri":"/clash-for-ubuntu/"},{"categories":["笔记"],"content":"应用配置 ","date":"2024/03/20","objectID":"/clash-for-ubuntu/:2:0","tags":["linux"],"title":"Clash for Linux/Ubuntu的使用说明","uri":"/clash-for-ubuntu/"},{"categories":["笔记"],"content":"应用下载与安装 下载当前操作系统与 CPU 架构对应的包文件，我这儿是 X86_64 平台下的，所以对应的使用clash-linux-amd64-v1.1.0.gz包即可。(实测Ubuntu 18.04/Ubuntu 20.04都没问题) 可以通过以下命令完成Clash安装工作。 在release中下载clash-for-linux-base.zip解压后，里面有两个文件Country.mmdb和clash。 # 解压缩后，移动clash文件 sudo mv ./clash /usr/local/bin/ sudo chmod +x /usr/local/bin/clash ","date":"2024/03/20","objectID":"/clash-for-ubuntu/:2:1","tags":["linux"],"title":"Clash for Linux/Ubuntu的使用说明","uri":"/clash-for-ubuntu/"},{"categories":["笔记"],"content":"添加Clash配置文件 Clash的运行需要两个文件Country.mmdb和config.yaml。 其中Country.mmdb在base文件夹里有了，config.yaml则存储着节点等配置，一般都是由机场等服务商提供。 这两个文件缺一不可 我个人习惯将这些配置文件存在主目录下的隐藏文件夹中。 mkdir ~/.clash mv ./Country.mmdb ~/.clash ","date":"2024/03/20","objectID":"/clash-for-ubuntu/:2:2","tags":["linux"],"title":"Clash for Linux/Ubuntu的使用说明","uri":"/clash-for-ubuntu/"},{"categories":["笔记"],"content":"设置启动脚本 创建 systemd 脚本，脚本文件路径为 /etc/systemd/system/clash.service。 cd /etc/systemd/system/ sudo gedit clash.service 在弹出的文件编辑器中粘贴以下内容，CtrlS保存后再关闭。 [Unit] Description=clash [Service] Type=simple User=root ExecStart=/usr/local/bin/clash -d /home/你的用户名/.clash/ Restart=on-failure [Install] WantedBy=multi-user.target 使用以下命令设置Clash自启动，并启动Clash # 重载服务配置 sudo systemctl daemon-reload # Clash服务自启动 sudo systemctl enable clash # 启动Clash服务 sudo systemctl start clash # 查看Clash状态 sudo systemctl status clash ","date":"2024/03/20","objectID":"/clash-for-ubuntu/:2:3","tags":["linux"],"title":"Clash for Linux/Ubuntu的使用说明","uri":"/clash-for-ubuntu/"},{"categories":["笔记"],"content":"设置本机网络代理 打开设置-\u003e网络，在网络代理一栏选择手动，并做出以下配置。 http代理、https代理: 127.0.0.1 7890 socks主机: 127.0.0.1 7891 至此所有配置就已经完成了，可以通过浏览器尝试访问Youtube检测是否设置成功。 ","date":"2024/03/20","objectID":"/clash-for-ubuntu/:2:4","tags":["linux"],"title":"Clash for Linux/Ubuntu的使用说明","uri":"/clash-for-ubuntu/"},{"categories":["笔记"],"content":"Clash可视化 在Clash设置成功后，直接访问以下链接即可查看当前机场的节点信息，可以实现简单的修改。 Clash可视化 ","date":"2024/03/20","objectID":"/clash-for-ubuntu/:3:0","tags":["linux"],"title":"Clash for Linux/Ubuntu的使用说明","uri":"/clash-for-ubuntu/"},{"categories":null,"content":" 简单的自我介绍 什么时间 什么地点 在做什么 2017-2021 五邑大学 电子信息工程，本科 2018-2021 广东省海量生物特征信息处理工程技术研究中心 算法学习 2021 江门市云争科技有限公司 算法工程师实习生 2021-2022 武汉环宇智行科技有限公司 AI算法工程师 2022-now 华中师范大学 计算机科学与技术，硕士 ","date":"2023/07/27","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["示例"],"content":"分别使用静态调用（隐式链接）和动态调用（显式链接）的方式调用dll","date":"2023/07/26","objectID":"/mydll/","tags":["c++"],"title":"DLL调用方式测试","uri":"/mydll/"},{"categories":["示例"],"content":"dll说明 dll（Dynamic Link Library，动态链接库），是一种可以被其它程序调用的程序。 dll文件可以包含代码、数据和资源，允许多个程序同时访问同一个dll文件，这样可以节省内存空间，提高系统性能。 dll的调用方式主要两种，动态调用（显式链接）和静态调用（隐式链接）。 由于调用方式不同，所以在代码编写时有有所不同，但是区别并不大。 可以通过上面的名称看出他们差异1体现在链接阶段。 所需文件如下： 静态调用 动态调用 .h .lib .dll (.h) .dll 在动态调用时，如果导出的只是函数则不需要.h。 如果导出的是一个抽象的功能基类2，则需要这个基类的头文件，具体实现类的头文件不需要。 ","date":"2023/07/26","objectID":"/mydll/:1:0","tags":["c++"],"title":"DLL调用方式测试","uri":"/mydll/"},{"categories":["示例"],"content":"一些细节 首先明确，调用的是动态链接库dll而不是静态链接库lib， 虽然生成dll时同样会存在lib3，但这个文件和前者有明显不同，完全是两码事。 其次，不论是上述哪种调用方式使用dll，程序在运行时都需要用到dll文件。 而lib文件只有使用静态调用的方式在链接阶段需要，动态调用的方式从始至终都不需要lib文件。 一般情况下认为，静态调用需要.h、.lib、.dll，动态调用需要.dll。 dll导出需要使用关键字__declspec(dllexport)标识，一般对它进行宏定义。 dll在设计之初只是为了方便导出函数级的接口，所以最好避免导出变量或类，可能会出现莫名其妙的crash4。 使用动态调用时需要注意，在导出后，编译器会对函数名称进行修改，形如?getInstance@@YA?AV?，可以通过Dependency Walker等工具5查看。 可以通过增加关键字extern \"C\"来避免这种情况，但这样会失去C++的重载功能。 静态调用时，在头部使用#pragma comment(lib, \"xxx.lib\")指定链接的lib文件。 经过测试发现新的一点，如果是使用cmake对项目进行编译，使用target_link_libraries指定链接的lib文件也能达到相同效果。 ","date":"2023/07/26","objectID":"/mydll/:2:0","tags":["c++"],"title":"DLL调用方式测试","uri":"/mydll/"},{"categories":["示例"],"content":"代码示例 // exportclass.h #ifndef __EXPORTCLASS_H__ #define __EXPORTCLASS_H__ #ifndef MYDLL_EXPORTS #define MYDLL_EXPORTS __declspec(dllexport) #else #define MYDLL_EXPORTS __declspec(dllimport) #endif class MYDLL_EXPORTS EX { public: EX(); void test(); }; #endif // __EXPORTCLASS_H__ // exportclass.cpp #include \u003ciostream\u003e #include \"exportclass.h\" EX::EX() {} void EX::test() { std::cout \u003c\u003c \"test\" \u003c\u003c std::endl; } // main.cpp #include \u003ciostream\u003e #include \u003cWindows.h\u003e #include \"module/exportclass.h\" #pragma comment(lib, \"mydll.lib\") // unnecessary while dynamic load void loadDllDyn(std::string funcName) { // Load DLL HMODULE myDLL = LoadLibrary(\"mydll.dll\"); if (myDLL != NULL) { // Get function pointer typedef EX (*GetInstanceFunc)(); GetInstanceFunc getInstance = (GetInstanceFunc)GetProcAddress(myDLL, funcName.c_str()); if (getInstance == NULL) { std::cout \u003c\u003c \"Error: getInstance function not found\" \u003c\u003c std::endl; } else { // Call function EX ex = getInstance(); ex.test(); } // Unload DLL FreeLibrary(myDLL); } else { std::cout \u003c\u003c \"Error: no dll be found\" \u003c\u003c std::endl; } } int main() { try { // dynamic load loadDllDyn(\"??0EX@@QEAA@XZ\"); // static load EX ex; ex.test(); } catch(const char* msg) { std::cout \u003c\u003c msg \u003c\u003c std::endl; } std::cout \u003c\u003c \"exit\" \u003c\u003c std::endl; return 0; } 为了偷懒，上面的例子中直接导出了整个实现类，并没有使用导出抽象基类或导出函数的方式，这点在编写代码时可优化。 ","date":"2023/07/26","objectID":"/mydll/:3:0","tags":["c++"],"title":"DLL调用方式测试","uri":"/mydll/"},{"categories":["示例"],"content":"参考资料 https://www.cnblogs.com/xiangtingshen/p/10979419.html “博客园: 动态链接库dll的静态加载与动态加载” ↩︎ https://blog.csdn.net/qiangzi4646/article/details/79628260 “CSDN: dll导出类比较好的方式” ↩︎ https://blog.csdn.net/qq_29007291/article/details/113439343 “CSDN: windows visual studio生成dll总是伴随着lib” ↩︎ https://club.topsage.com/thread-497586-1-1.html “论坛: DLL导出类避免地狱问题的完美解决方案” ↩︎ https://github.com/JelinYao/dependency “GitHub: dependency” ↩︎ ","date":"2023/07/26","objectID":"/mydll/:4:0","tags":["c++"],"title":"DLL调用方式测试","uri":"/mydll/"},{"categories":["笔记"],"content":"一些coding、论文、优化算法、强化学习、深度学习的知识。","date":"2023/07/16","objectID":"/research/","tags":["research"],"title":"论文那些事儿","uri":"/research/"},{"categories":["笔记"],"content":"基础知识 Base Softmax和Sigmoid，详解1 2 小结 都可用于多分类问题中，Sigmoid函数常用于有多个正确答案的分类问题，Softmax函数常用于有一个正确答案的分类问题。 tanh，详解3 torch.gather函数详解4，见汤胤评论 ","date":"2023/07/16","objectID":"/research/:1:0","tags":["research"],"title":"论文那些事儿","uri":"/research/"},{"categories":["笔记"],"content":"深度学习 Deep Learning LSTM，详解5 6 小结 LSTM通过门控状态来控制传输状态，忘记+选择性记忆=输出。 GRU，详解7，论文8 小结 GRU效果与LSTM相近，减少了计算量。 Attention，详解9，视频10 11 Transformer，详解12 ","date":"2023/07/16","objectID":"/research/:2:0","tags":["research"],"title":"论文那些事儿","uri":"/research/"},{"categories":["笔记"],"content":"强化学习 Reinforcement Learning SARSA，详解13 Q-Learning，详解14 小结 DQN，详解15 ","date":"2023/07/16","objectID":"/research/:3:0","tags":["research"],"title":"论文那些事儿","uri":"/research/"},{"categories":["笔记"],"content":"参考资料 Reference https://www.jianshu.com/p/037bf733713f “简书: 分类问题中Sigmoid与Softmax区别” ↩︎ https://devpress.csdn.net/xian/64a6246db1e197348be16c6a.html “论坛: 三分钟认知Softmax和Sigmoid的详细区别” ↩︎ https://www.jianshu.com/p/7409c8f1cdca “简书: 神经网络中的激活函数-tanh” ↩︎ https://zhuanlan.zhihu.com/p/352877584 “知乎: 图解PyTorch中的torch.gather函数” ↩︎ https://zhuanlan.zhihu.com/p/32085405 “知乎: 人人都能看懂的LSTM” ↩︎ https://zhuanlan.zhihu.com/p/42717426 “知乎: 详解LSTM” ↩︎ https://zhuanlan.zhihu.com/p/32481747 “知乎: 人人都能看懂的GRU” ↩︎ https://arxiv.org/pdf/1412.3555.pdf “论文: Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling” ↩︎ https://zhuanlan.zhihu.com/p/46313756 “知乎: Attention机制简单总结” ↩︎ https://www.bilibili.com/video/BV1q3411U7Hi “Bili: Attention、Transformer公式推导和矩阵变化” ↩︎ https://zhuanlan.zhihu.com/p/46313756 “知乎: Attention机制简单总结” ↩︎ https://zhuanlan.zhihu.com/p/166608727 “知乎: 举个例子讲下transformer的输入输出细节及其他” ↩︎ ./RL/common_alg/SARSA.md “文档: SARSA” ↩︎ ./RL/common_alg/Q-Learning.md “文档: Q-Learning” ↩︎ https://paddlepedia.readthedocs.io/en/latest/tutorials/reinforcement_learning/DQN.html “文档: DQN” ↩︎ ","date":"2023/07/16","objectID":"/research/:4:0","tags":["research"],"title":"论文那些事儿","uri":"/research/"},{"categories":["示例"],"content":"Pytorch测试GPU是否可用。","date":"2023/06/03","objectID":"/pytorch-gpu-test/","tags":["python"],"title":"Pytorch测试GPU是否可用","uri":"/pytorch-gpu-test/"},{"categories":["示例"],"content":"pytorch分为cpu和gpu两个版本，若需要验证gpu版本是否安装成功可以通过以下命令 import torch # 返回当前设备索引 torch.cuda.current_device() # 返回gpu数量 torch.cuda.device_count() # 返回gpu名称，索引从0开始 torch.cuda.get_device_name(0) # cuda是否可用 torch.cuda.is_available()","date":"2023/06/03","objectID":"/pytorch-gpu-test/:0:0","tags":["python"],"title":"Pytorch测试GPU是否可用","uri":"/pytorch-gpu-test/"},{"categories":["杂谈"],"content":"关于近日使用京东读书APP的一些体验感受。","date":"2023/05/27","objectID":"/jd_reader/","tags":[],"title":"关于近日使用京东读书APP的一些体验感受","uri":"/jd_reader/"},{"categories":["杂谈"],"content":"前几天jd会员要到期了，想买点小东西没有运费券嫖了，就想着再续个会员， 无意间看了一下jd plus的会员权益，发现里面权益还真不少啊。 比起前些年来说，现在的权益涉及方方面面，其他的就不多说了，毕竟不是来打广告的。 没多久我在角落里发现了一个京东读书的权益，毕竟上了研究生以来爱上了看书。 简单使用了一下，APP功能肯定和其他的无异，毕竟读书APP嘛，也没啥花活可以整， 同时也很明显的感受到，这个APP应该尚在起步阶段，很多微信读书APP的功能它都没有。 主要值得吐槽的一点是，APP内部的书籍资源主要还是以售卖为主，本来猜测开通会员后可以在有效期内查看这些书籍的， 后来发现然并卵。会员免费的书籍资源是独立出来的，也就是说开了会员，这个会员库里的书籍对于会员来说是免费的， 不在这个库里的书，该收费还是要收费，对于购书来说倒是一个不小的便利。（还好只是1￥开了7天会员试试水，验证自己的猜想。） 但对于想白嫖看书来说，显然是不太可能的了。 值得一提的是，京东读书内部也有一个导入书籍的功能，等微信读书上传的免费数量（200本）用完以后，再去体验一下吧。 就现在而言，还是先用着微信读书吧，毕竟每天看一会儿书就能白嫖体验卡，能看更多的书，无论是从体验还是心理感受来看都是更香的。 ","date":"2023/05/27","objectID":"/jd_reader/:0:0","tags":[],"title":"关于近日使用京东读书APP的一些体验感受","uri":"/jd_reader/"},{"categories":["折腾","示例"],"content":"将第三方手柄输出映射到鼠标上。","date":"2023/05/21","objectID":"/diy-gamepad/","tags":["python"],"title":"将第三方手柄输出映射到鼠标上","uri":"/diy-gamepad/"},{"categories":["折腾","示例"],"content":"说明 将游戏手柄的摇杆映射为鼠标滚轮操作， 当前只是将向上和向下操作映射为鼠标滚轮的上下滚动。 通过pynput库完全可以更大程度的映射手柄操作， 鼠标指针移动 鼠标点击 键盘快捷键 … 更多pynpug库接口，可参看官方文档1。 ","date":"2023/05/21","objectID":"/diy-gamepad/:1:0","tags":["python"],"title":"将第三方手柄输出映射到鼠标上","uri":"/diy-gamepad/"},{"categories":["折腾","示例"],"content":"全部代码 # @auth: afeng # @desc: get gamepad input and output mouse cmd # @date: 2023/05/21 import pygame from pynput.mouse import Controller pygame.init() clock = pygame.time.Clock() pygame.joystick.init() mouse = Controller() scroll_offset = .2 # gamepad joystick = pygame.joystick.Joystick(0) joystick.init() name = joystick.get_name() print(f\"Joystick name: {name}\".format(name)) while True: for event in pygame.event.get(): # User did something pass # if event.type == pygame.QUIT: # If user clicked close # done=True # Flag that we are done so we exit this loop axes = joystick.get_numaxes() for i in range( axes ): if i==0 or i==3: continue axis = joystick.get_axis( i ) # Axis 0: -1 left, 1 right # Axis 1: -1 up, 1 down # Axis 2: -1 up, 1 down # Axis 3: -1 left, 1 right # mouse scroll dy: -1 down, 1 up mouse.scroll(0, -i*axis*scroll_offset) clock.tick(20) https://pynput.readthedocs.io/en/latest/ “pynput库官方文档” ↩︎ ","date":"2023/05/21","objectID":"/diy-gamepad/:2:0","tags":["python"],"title":"将第三方手柄输出映射到鼠标上","uri":"/diy-gamepad/"},{"categories":["笔记"],"content":"混合牛顿法。","date":"2023/05/14","objectID":"/newton_hybrid/","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"综述 所谓混合牛顿法1是指结合牛顿法和梯度下降法的特点，若牛顿方向可行，则使用牛顿法进行迭代，若不行，则使用梯度下降法确定搜索方向。 具体搜索方向选取的逻辑可以是这样的： $$ \\begin{align} \u0026if\\ \\nabla^2 f(x_k)正定,则\\quad d_k=-\\nabla^2f(x_k)^{-1}\\nabla f(x_k)\\\\ \u0026if\\ \\nabla^2f(x_k)负定,则\\quad d_k=\\nabla^2f(x_k)^{-1}\\nabla f(x_k)\\\\ \u0026else\\ \\quad\\quad d_k=-\\nabla f(x_k) \\end{align} $$ ","date":"2023/05/14","objectID":"/newton_hybrid/:1:0","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"细节说明 ","date":"2023/05/14","objectID":"/newton_hybrid/:2:0","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"Hessian矩阵 关于Hessian矩阵（$\\nabla^2 f(x_k)$）的正定性说明2。 简单地说，如果Hessian矩阵正定，则 函数的二阶偏导数恒 \u003e 0 函数的变化率（斜率）即一阶导数始终处于递增状态 函数为凸 ","date":"2023/05/14","objectID":"/newton_hybrid/:2:1","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"牛顿法 牛顿法求解方程近似解 若求解$f(x)=0$在$\\mathbb R$上的解$x^*$，通过选取迭代初值$x_0$，使用牛顿迭代公式逼近$x^*$。 $$ x_{t+1}=x_t-\\frac{f(x_t)}{f'(x_t)} $$ 将​$f(x)$在迭代初值$x_0$​处Taylor展开可得： $$ f(x)=f(x_0)+f'(x_0)(x-x_0)+o(|x-x_0|) $$ 舍去高阶项，可得： $$ f(x)=f(x_0)+f'(x_0)(x-x_0) $$ 将零点$x^*$代入可得： $$ f(x^*)=0=f(x_0)+f'(x_0)(x^*-x_0) \\\\ x^*=x_0-\\frac{f(x_0)}{f'(x_0)} $$ 由于上式是舍去了高阶项后的近似，因此我们实际上并不能根据上式一步得到$x^*$​。而要通过多步迭代，由此得到牛顿迭代方程： $$ x_{t+1}=x_t-\\frac{f(x_t)}{f'(x_{t})} $$ 牛顿法在最优化上的应用 对于一阶可微的函数​$f:\\mathbb R\\to\\mathbb R$ ，根据费马定理，其极值点$x^*$​满足$f'(x^*)=0$，而最优化方法的目的也就是通过种种手段，求出或近似这个极值点$x^*$。注意到牛顿法是用来求解函数$g(x)$​的一个零点的近似值​$\\hat x$的，而最优化则是求解导数的零点的近似解，那么令$g(x)=f'(x)$​，迭代出来的​$\\hat x$不就是极值点$x^*$​的近似解了吗？ 因此，使用牛顿法优化函数$f$的迭代方程也就呼之欲出了： $$ x_{t+1}=x_t-\\frac{g(x_t)}{g'(x_t)}=x_t-\\frac{f'(x_t)}{f''(x_t)}=x_t-f''(x_t)^{-1}f'(x_t) $$ 当然，这需要​$f$是二阶可导的，此处就默许我们研究的函数足够正定。 上述为一维输入的情形，对于​$f:\\mathbb R^n\\to\\mathbb R$也有类似的迭代式： $$ x_{t+1}=x_t-\\nabla^2f(x_t)^{-1}\\nabla f(x_t)\\quad\\quad x_t\\in\\mathbb R^n\\ $$ 其证明方法和一维情形几乎一致。 牛顿法优化函数算法过程 牛顿法优化函数的算法： $$ \\begin{align} 选定\u0026迭代初值x_0\\in\\Omega,选取\\epsilon\u003e0,重复以下操作:\\\\ \u0026若||\\nabla f(x_t)||\u003c\\epsilon，停止循环\\\\ \u0026计算梯度:\\nabla f(x_t)\\\\ \u0026计算Hessian矩阵:\\nabla^2f(x_t)\\\\ \u0026计算方向:d_t=-\\nabla^2f(x_t)^{-1}\\nabla f(x_t)\\\\ \u0026更新迭代点:x_{t+1}=x_t-d\\\\ \\end{align} $$ ","date":"2023/05/14","objectID":"/newton_hybrid/:2:2","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"与梯度下降法比较 牛顿法： $$ x_{t+1}=x_t-\\nabla^2f(x_t)^{-1}\\nabla f(x_t) $$ 梯度下降法： $$ x_{t+1}=x_t-\\gamma\\nabla f(x_t) $$ 可以发现，这两个方法都是基于当前迭代点的梯度信息进行搜索方向的选择的，只不过梯队下降法是在梯度的反方向上进行线搜得到下一个迭代点，而牛顿法则是通过Hessian矩阵在梯度上进行线性变换得到搜索方向（甚至步长都不需要确定）。 所以牛顿法对函数在迭代点处的信息利用更加充分，直观来看，相比于梯度下降法，函数足够正则的情况下牛顿法迭代得更加准确，收敛速率也会更快。 所有基于梯度的迭代方程可以写成如下的形式： $$ x_{t+1}=x_t-H(x_t)\\nabla f(x_t) $$ 其中$x\\in\\mathbb R^n,H(x_t)\\in\\mathbb R^{n\\times n}$。 对于牛顿法来说，$H(x_t)=\\nabla^2f(x_t)^{-1}$ 对于梯度下降法来说，$H(x_t)=\\gamma I$ 可以看到，牛顿法$H$的​是随着当前迭代点的变化动态变化的，因此，相比于梯度下降法，牛顿法具有更加灵活的迭代过程。有的书上直接说牛顿法就是“自适应的梯度下降法”。 ","date":"2023/05/14","objectID":"/newton_hybrid/:2:3","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"参考 https://zhuanlan.zhihu.com/p/293951317 “知乎: 最优化方法复习笔记（三）牛顿法及其收敛性分析” ↩︎ https://blog.csdn.net/qq_39521554/article/details/78895869 “CSDN: Hessian矩阵正定与函数凹凸性的关系” ↩︎ ","date":"2023/05/14","objectID":"/newton_hybrid/:3:0","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["示例"],"content":"md渲染测试","date":"2023/05/12","objectID":"/blog-test/","tags":["markdown"],"title":"Blog Test","uri":"/blog-test/"},{"categories":["示例"],"content":"事件发展 ","date":"2023/05/12","objectID":"/blog-test/:1:0","tags":["markdown"],"title":"Blog Test","uri":"/blog-test/"},{"categories":["示例"],"content":"content This is a test blog. This is my first blog at GitHub Page website! This is a test blog. This is my first blog at GitHub Page website! This is a test blog. This is my first blog at GitHub Page website! This is a test blog. This is my first blog at GitHub Page website! This is a test blog. This is my first blog at GitHub Page website! ","date":"2023/05/12","objectID":"/blog-test/:2:0","tags":["markdown"],"title":"Blog Test","uri":"/blog-test/"},{"categories":["示例"],"content":"数学公式 $$ \\begin{aligned} Q_(n+1)\u0026=\\frac{1}{n}\\sum_{i=1}^nR_i \\\\\\\\ \u0026=Q_n+\\frac{1}{n}(R_n-Q_n) \\end{aligned} $$ $$ \\begin{aligned} Q_(n+1)\u0026=\\frac{1}{n}\\sum_{i=1}^nR_i \\\\ \u0026=Q_n+\\frac{1}{n}(R_n-Q_n) \\end{aligned} $$ ","date":"2023/05/12","objectID":"/blog-test/:3:0","tags":["markdown"],"title":"Blog Test","uri":"/blog-test/"},{"categories":["示例"],"content":"参考 GitHub: Github Pages + Hugo 搭建个人博客 少数派: Hugo + GitHub Action，搭建你的博客自动发布系统 ","date":"2023/05/12","objectID":"/blog-test/:4:0","tags":["markdown"],"title":"Blog Test","uri":"/blog-test/"},{"categories":["折腾","示例"],"content":"快手取关脚本。","date":"2022/04/04","objectID":"/kuaishou-unsubscript/","tags":["javascript"],"title":"快手取关脚本","uri":"/kuaishou-unsubscript/"},{"categories":["折腾","示例"],"content":"简单的元素筛选，模拟点击即可！ ","date":"2022/04/04","objectID":"/kuaishou-unsubscript/:0:0","tags":["javascript"],"title":"快手取关脚本","uri":"/kuaishou-unsubscript/"},{"categories":["折腾","示例"],"content":"代码 let num = 0 for (let tmp of document.getElementsByClassName('container')){ tmp.children[2].children[0].click() console.log('取关', ++num) } ","date":"2022/04/04","objectID":"/kuaishou-unsubscript/:1:0","tags":["javascript"],"title":"快手取关脚本","uri":"/kuaishou-unsubscript/"},{"categories":["折腾","示例"],"content":"使用方法 进入快手网页版个人页面-\u003e关注一栏，如https://www.kuaishou.com/profile/kuaishou_id，多次按下CtrlEnd组合键使页面滚动到最下端（方便一次运行完毕），F12打开开发者工具，输入上述命令运行即可。 ","date":"2022/04/04","objectID":"/kuaishou-unsubscript/:2:0","tags":["javascript"],"title":"快手取关脚本","uri":"/kuaishou-unsubscript/"},{"categories":["折腾","示例"],"content":"Twitter取关脚本。","date":"2022/04/03","objectID":"/twitter-unsubscript/","tags":["javascript"],"title":"Twitter取关脚本","uri":"/twitter-unsubscript/"},{"categories":["折腾","示例"],"content":"由于Twitter页面显示情况较特殊，暂时没有找到更高效的批量取关方法。 ","date":"2022/04/03","objectID":"/twitter-unsubscript/:0:0","tags":["javascript"],"title":"Twitter取关脚本","uri":"/twitter-unsubscript/"},{"categories":["折腾","示例"],"content":"代码 let btns = document.querySelectorAll(\"[data-testid]\") let followBtns = Array.from(btns).filter(btn =\u003e { return btn.getAttribute('data-testid').includes('unfollow') }) for (let i = 1; i \u003c= followBtns.length; i++) { followBtns[i - 1].click(); let _span = document.getElementsByTagName('span'); for (var j = 0; j \u003c _span.length; j++) { if (_span[j].textContent == \"取消关注\") { _span[j].click(); console.log(\"取关\"); } } } ","date":"2022/04/03","objectID":"/twitter-unsubscript/:1:0","tags":["javascript"],"title":"Twitter取关脚本","uri":"/twitter-unsubscript/"},{"categories":["折腾","示例"],"content":"使用说明 使用网页版Twitter进入个人资料-\u003e正在关注页面，网址例如https://twitter.com/xxxxx/following。 F12调出开发者工具，在console栏中输入上述代码。每次运行能取关几十人，多运行几次就行。 ","date":"2022/04/03","objectID":"/twitter-unsubscript/:2:0","tags":["javascript"],"title":"Twitter取关脚本","uri":"/twitter-unsubscript/"},{"categories":["折腾"],"content":"删除设备和驱动器中的图标。","date":"2022/04/01","objectID":"/delete-win-driver-logo/","tags":["windows"],"title":"删除设备和驱动器中的图标","uri":"/delete-win-driver-logo/"},{"categories":["折腾"],"content":"说明 情况是这样的 设备和驱动器多余图标 ","date":"2022/04/01","objectID":"/delete-win-driver-logo/:1:0","tags":["windows"],"title":"删除设备和驱动器中的图标","uri":"/delete-win-driver-logo/"},{"categories":["折腾"],"content":"操作 主要操作如下： 打开注册表（WINR键入regedit） 搜索路径 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\ 删除不需要的图标项 修改注册表 ","date":"2022/04/01","objectID":"/delete-win-driver-logo/:2:0","tags":["windows"],"title":"删除设备和驱动器中的图标","uri":"/delete-win-driver-logo/"},{"categories":["笔记"],"content":"计算机网络参考模型。","date":"2022/03/15","objectID":"/computer-network-osi/","tags":["计算机网络"],"title":"计算机网络参考模型","uri":"/computer-network-osi/"},{"categories":["笔记"],"content":"OSI和TCP/IP标准 ","date":"2022/03/15","objectID":"/computer-network-osi/:1:0","tags":["计算机网络"],"title":"计算机网络参考模型","uri":"/computer-network-osi/"},{"categories":["笔记"],"content":"综合标准 经过综合考量当前认定的标准是五层结构 分层单位协议应用层报文FTP、SMTP、HTTP传输层报文段TCP、UDP网络层数据报IP、ICMP、OSPF数据链路层帧PPP、Ethernet物理层比特","date":"2022/03/15","objectID":"/computer-network-osi/:2:0","tags":["计算机网络"],"title":"计算机网络参考模型","uri":"/computer-network-osi/"},{"categories":["折腾"],"content":"CentOS7重装python以及yum。","date":"2022/02/17","objectID":"/centos-reinstall-sth/","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"没事千万别拿环境开玩笑！ ​——沃兹基·硕德 轻易不要尝试 轻易不要尝试 轻易不要尝试 由于之前使用的python版本过低，无法使用很多模块的新特性。然而在尝试更新python版本时遇到了很多坑，不仅把原python3更新为新版本后，原yum不能用了，而且pip也无法正常工作。且卸载python3老版本的时候不小心吧python2给卸载了，yum又需要python2。几番尝试之后无果，干脆全部重装算了！ ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:0:0","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"卸载原python、yum 卸载现有python（所有版本及模块）。 rpm -qa|grep python|xargs rpm -ev --allmatches --nodeps ##强制删除已安装程序及其关联 whereis python |xargs rm -frv ##删除所有残余文件 ##xargs，允许你对输出执行其他某些命令 whereis python ##验证删除，返回无结果 卸载现有yum。 rpm -qa|grep yum|xargs rpm -ev --allmatches --nodeps whereis yum |xargs rm -frv ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:1:0","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装python2 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:2:0","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装python2.7.15 使用python.org下载太慢，这里使用淘宝镜像下载。 https://registry.npmmirror.com/-/binary/python/2.7.15/Python-2.7.15.tgz cd /usr/local/src wget https://registry.npmmirror.com/-/binary/python/2.7.15/Python-2.7.15.tgz tar -zxvf Python-2.7.15.tgz cd Python-2.7.15 ./configure make \u0026\u0026 make install 创建软链接，将python2.7.15版本命名为python2，将python留给python3版本使用。 ln /usr/local/bin/python /usr/local/bin/python2 将涉及/usr/bin/python的设置更新为/usr/bin/python2，毕竟python2.7的软链接已经被改成了python2。 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:2:1","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装pip 查找网上的教程都是通过以下yum命令安装的，然而我却总是显示没有匹配包，我也是挺无奈的。 yum -y install python-pip 干脆就直接使用源码安装算了，反正也不复杂。 # 1.下载python-pip包 wget https://pypi.python.org/packages/source/p/pip/pip-1.3.1.tar.gz --no-check-certificate # 2.安装pip之前需要先安装setuptools wget https://pypi.python.org/packages/2.7/s/setuptools/setuptools-0.6c11-py2.7.egg --no-check-certificate chmod +x setuptools-0.6c11-py2.7.egg sh setuptools-0.6c11-py2.7.egg # 3.安装pip chmod +x pip-1.3.1.tar.gz tar xzvf pip-1.3.1.tar.gz cd pip-1.3.1 python setup.py install 可以愉快的使用pip了。 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:2:2","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装yum 据说yum的使用需要用到python2，具体我也没有细究，反正至少先安装好python2就行了。 以下链接与CentOS版本相关，具体链接可在网易镜像中依照具体系统查找。 cat /etc/centos-release # 查看系统版本号 # CentOS Linux release 7.6.1810 (Core) ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:3:0","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"下载相关文件 wget http://mirrors.163.com/centos/7/os/x86_64/Packages/python-urlgrabber-3.10-8.el7.noarch.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/python-iniparse-0.4-9.el7.noarch.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-45.el7.noarch.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-3.4.3-158.el7.centos.noarch.rpm ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:3:1","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"按照顺序安装 rpm -ivh python-iniparse-0.4-9.el7.noarch.rpm rpm -ivh python-urlgrabber-3.10-8.el7.noarch.rpm rpm -ivh yum-3.4.3-158.el7.centos.noarch.rpm yum-metadata-parser-1.1.4-10.el7.x86_64.rpm yum-plugin-fastestmirror-1.1.31-45.el7.noarch.rpm 注意：yum和yum-plugin-xxx一定要同时安装，因为他们彼此依赖，先安装谁都会报错。 安装中途很可能会出现依赖错误导致安装失败，如python(abi) = 2.7 is needed by xxx。 该错误则需要安装以下几个包： python-libs-2.7.5-68.el7.x86_64.rpm python-2.7.5-68.el7.x86_64.rpm python-devel-2.7.5-68.el7.x86_64.rpm 注意：在安装时仍然会遇到依赖错误，那么安装提示在网易镜像中查找对应版本文件，使用wget下载后安装即可。 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:3:2","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"修改yum源 在使用yum安装时出现http404之类的错误，很有可能就是yum源有问题。 # 1.进入系统yum源目录 cd /etc/yum.repos.d # 2.备份原来的yum源 mkdir bak \u0026\u0026 mv *.repo bak # 3.下载yum源 wget http://mirrors.163.com/.help/CentOS7-Base-163.repo # 4.改名成默认repo mv CentOS7-Base-163.repo CentOS-Base.repo # 5.生成缓存，是配置生效 yum makecache # 6.验证配置源 yum repolist # 查看是否有163的标识 # 7.更新yum文件 yum update -y 接下来就可以正常使用yum了。 注意：修改时可能遇到/usr/bin/applydeltarpm not installed的情况 缺什么安装什么就完事了！ yum provides '*/applydeltarpm' yum install deltarpm -y ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:3:3","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装python3 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:4:0","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装python3.8 现在使用python开发基本都是使用python3了，自然不能少。python不能装太老的，因为以后可能官方就不支持了，也不能太新，因为还不稳定，资料也不够多，所以综合考虑python3.8就差不多了。 cd /usr/local/src wget https://registry.npmmirror.com/-/binary/python/3.8.8/Python-3.8.8.tgz tar -zxvf Python-3.8.8.tgz cd Python-3.8.8 ./configure make \u0026\u0026 make install ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:4:1","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"修改python3为默认 安装后通过python3就能使用该版本，不过一般都习惯只键入python，所以在这里创建软链接即可 which python3 # 查看python3位置 # /usr/local/bin/python3 ln /usr/local/bin/python3 /usr/local/bin/python # 创建软链接 python -V # 查看版本 # Python 3.8.8 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:4:2","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"配置pip3 python3.8安装成功后，pip3就已经安装完毕了！键入pip3就能正常使用，如果想将它设为默认的话，可以修改软链接。当然这一步其实可以不配置 which pip # 查看原pip # /usr/local/bin/pip mv /usr/local/bin/pip /usr/local/bin/pip_bak # 备份 which pip3 # 查看pip3位置 # /usr/local/bin/pip3 ln /usr/local/bin/pip3 /usr/local/bin/pip # 创建软链接 pip -V 查看当前pip版本 pip 20.2.3 from /usr/local/lib/python3.8/site-packages/pip (python 3.8) 完事！还是python3安装最简单。 至此终于把整个重装工作完成了！ 网上的资料真是太坑了，要么不详细，要么根本就是直接偷别人的。fo了！ ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:4:3","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"远程开机的实现分析。","date":"2022/01/25","objectID":"/remote-wol/","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"这次开发的需求很简单，就是想使用移动端通过互联网实现对主机的开机、关机、休眠、睡眠以及重启的控制。 明确了需求后就开始构思解决方案，在此过程中，通过互联网了解到市场上存在能完成该任务的产品。于是我就开始对其中的HiPC[1]进行了了解，发现该产品由软件端（小程序及pc端应用）和硬件端（类似二次开发的网卡）组成，再结合搜索到的资料，我大致了解整个过程的实现思路。 ","date":"2022/01/25","objectID":"/remote-wol/:0:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"HiPC的实现思路 该实现思路为本人摸索得出，仅供参考，侵权删！ 下载并使用HiPC的PC端应用程序后不难发现，仅使用该程序就可以配合小程序经过互联网完成对PC的远程关机、休眠、睡眠以及重启控制，而想使用开机功能（无论通过局域网还是广域网）则需要购买其硬件产品。将焦点放在PC端程序还发现，若想完成上述操作，该程序还必须在PC上正常运行。 ","date":"2022/01/25","objectID":"/remote-wol/:1:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"除开机外其他控制的实现 经过简单的分析发现，此应用与云服务器建立了WebSocket连接，使得该应用能够将PC的实时状态上传至服务器，同时使小程序能及时更新PC数据，并完成对PC的操作控制。 HiPC.exe后台监控PC状态，并通过WebSocket传输数据给服务器小程序发送指令至服务器，服务器通过WebSocket将指令转发给HiPC.exe使其执行相应指令 ![HiPC实现逻辑][hipc-process] 通过以上的方式使得用户能脱离局域网完成对PC除开机以外的其他控制。 ","date":"2022/01/25","objectID":"/remote-wol/:1:1","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"开机功能的实现 开机功能实质是唤醒PC，在PC进入关机、休眠、睡眠状态下，系统中原有的运行程序将停止正常工作。因此，无法再通过上述的逻辑实现远程唤醒操作。 这时候再将关注点放在硬件设备上，即HiPC售卖的PCI-E设备。经过简单分析，初步判断该设备为经过特定编程开发的网卡，实质通过WoL[2]完成对主机的唤醒。使用WoL需要有两个前提：1.主板支持；2.网卡支持。实现简单的局域网唤醒[3]满足以上两个条件经过简单设置就能实现，简单的原理就是处在同一局域网内的某设备向目标PC的网卡地址发送UDP数据包，网卡接收到指定格式数据后通过主板唤醒主机。 本地唤醒 然而想完成远程唤醒，还需要满足一个较苛刻的条件，即实现外网向内网指定网卡发包。绝大部分家庭使用的网络IP都是动态的，大部分家庭网络IP更是经过多层路由转发，因此其网关WAN IP都有可能是内网IP，而内网对于外网而言是透明的。由此，实现精准发包就需要下一点功夫了，这也是HiPC配合硬件端完成的工作。 在已经实现局域网内开机功能后，经过了几天的探索，最终确立了能够实现远程控制的方案。 ","date":"2022/01/25","objectID":"/remote-wol/:1:2","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"方案 局域网实现对PC的控制 需要：主板支持；网卡支持； 局域网开机可以根据WoL网络唤醒实现其他操作完全可以下载HiPC.exe完成广域网实现对PC的控制 需要：主板支持；网卡支持；路由器支持；服务器；公网IP； 依照WoL原理，从服务器发送udp数据包，经过互联网传输到有公网IP的网关WAN口，通过端口映射进入内网，通过路由器将数据包转发给指定网卡 远程唤醒 其他操作依赖HiPC.exe对于除开机外的其他操作，虽然可以完全手写，但个人觉得完全没必要。 ","date":"2022/01/25","objectID":"/remote-wol/:2:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"远程开机实现细节 该实现细节建立在方案1完成的前提下，依照【局域网使用WoL网络唤醒】可完成方案1实施 依照上述方案2实现通过互联网远程唤醒主机，需要考虑的问题如下： Q：为什么不使用花生壳做内网穿透？ A：在进行方案尝试时，是存在使用花生壳的想法的，但是在具体实施时发现了问题：计算机需要保持花生壳客户端的运行才能使内网穿透正常，对于待唤醒的PC，这点自然无法满足。个人认为花生壳适合用于搭建服务器，使用户能通过互联网访问到本地服务器资源，与本需求相悖，同时也确实没有必要。在路由器上使用花生壳提供的DDNS服务时，总是会有莫名的错误导致无法达到预期效果，最终放弃了这个方案。 Q：为什么要进行网关和路由器的端口映射？ A：本需求只要求某PC网卡能接收到来自公网的数据包。拥有公网IP的WAN口可以直接收到来自互联网的数据包，这时对网关进行端口映射使指定外部端口映射到内网某IP的端口，使得来自公网的数据能够被内网的设备接收到。若目标PC与网关间存在其他路由器，则相应路由器中也应该做好端口映射，以保证目标设备能接收到转发的数据包。 Q：即便申请到了公网IP，家庭用网的公网IP是动态的，如何确保发包目的地址为目标PC网卡？ A：网络运营商虽然可以接受个人申请使用公网IP，但是非专线（固定公网IP）的用户使用的公网IP是动态的。由于同一网关下的所有连接设备都共用一个公网IP，所以一开始设想让目标PC定时发送公网IP给服务器供其更新。随后觉得这个想法不合理，如果公网IP在PC未启动时更新，奈何？所以想到使用移动端代替原设想中PC的功能。移动设备设置自动化任务，通过指定API获取最新的公网IP发送至服务器供其更新。 ","date":"2022/01/25","objectID":"/remote-wol/:3:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"总结 在网卡和主板支持的前提下，基本可以无压力的实现局域网内的开机控制。而仅使用HiPC开发的应用程序就能实现远程（通过互联网也可）控制PC关机、休眠、重启等操作。若在不购置开机卡的前提下想通过互联网完成开机控制，就多少需要花些心思了。 ","date":"2022/01/25","objectID":"/remote-wol/:4:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"References HiPC \"HiPC官网\" ↩︎ Wake on Lan原理 \"向指定网卡发送指定格式的UDP数据包\" ↩︎ 局域网使用WoL网络唤醒 \"局域网某设备向目标PC网卡发送WoL包\" ↩︎ ","date":"2022/01/25","objectID":"/remote-wol/:5:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["示例"],"content":"Clipboard.js使用实例。","date":"2022/01/13","objectID":"/demo-clipboardjs/","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"说明 通过Clipboard.js可以完成对指定元素原格式内容的复制功能。 使用时需要注意以下两点： 新建Clipboard对象时，指定触发对象 触发对象最好使用\u003cbutton\u003e元素 ","date":"2022/01/13","objectID":"/demo-clipboardjs/:1:0","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"代码说明 ","date":"2022/01/13","objectID":"/demo-clipboardjs/:2:0","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"动态添加复制按钮 在网页指定位置添加触发器，即按钮（使用了JQuery，也可通过JavaScript原生代码编写） // 添加复制按钮 $('.toolbar').append('\u003cbutton class=\"button copy-button\"\u003e\u003cspan\u003eCopy\u003c/span\u003e\u003c/button\u003e'); ","date":"2022/01/13","objectID":"/demo-clipboardjs/:2:1","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"动态指定复制目标 可以在不修改html的情况下，通过编辑js代码完成创建Clipboard对象，并添加触发器 // 创建Clipboard对象并完成初始化 var copyCode = new Clipboard('.copy-button', { target: function (trigger) { return trigger.parentElement.previousElementSibling; } }); ","date":"2022/01/13","objectID":"/demo-clipboardjs/:2:2","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"编写回调函数 // Clipboard对象的回调函数（复制成功，复制失败） copyCode.on('success', function (event) { event.clearSelection(); event.trigger.textContent = 'Copied'; window.setTimeout(function () { event.trigger.textContent = 'Copy'; }, 2000); }); copyCode.on('error', function (event) { event.trigger.textContent = 'Error'; window.setTimeout(function () { event.trigger.textContent = 'Copy'; }, 2000); }); ","date":"2022/01/13","objectID":"/demo-clipboardjs/:2:3","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"完整代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eClipboard.js使用实例\u003c/title\u003e \u003cstyle\u003e .button { display: inline-block; height: auto; border-radius: 5px; padding: 3px 8px; border: 2px solid rgb(8, 230, 238); } .container { display: inline-block; height: auto; padding: 10px 15px; border: 3px dotted greenyellow; border-radius: 5px; } \u003c/style\u003e \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.4.0/clipboard.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv style=\"text-align: center;\"\u003e \u003cdiv class=\"container\"\u003e \u003ccode\u003eClipboard\u003c/code\u003e \u003cdiv class=\"toolbar\"\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"container\"\u003e \u003ccode\u003e使用\u003c/code\u003e \u003cdiv class=\"toolbar\"\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"container\"\u003e \u003ccode\u003e实例\u003c/code\u003e \u003cdiv class=\"toolbar\"\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript\u003e $('.toolbar').append('\u003cbutton class=\"button copy-button\"\u003e\u003cspan\u003eCopy\u003c/span\u003e\u003c/button\u003e'); var copyCode = new Clipboard('.copy-button', { target: function (trigger) { return trigger.parentElement.previousElementSibling; } }); copyCode.on('success', function (event) { event.clearSelection(); event.trigger.textContent = 'Copied'; window.setTimeout(function () { event.trigger.textContent = 'Copy'; }, 2000); }); copyCode.on('error', function (event) { event.trigger.textContent = 'Error'; window.setTimeout(function () { event.trigger.textContent = 'Copy'; }, 2000); }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e","date":"2022/01/13","objectID":"/demo-clipboardjs/:3:0","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["折腾"],"content":"Win10自启动管理。","date":"2022/01/12","objectID":"/win-self-startup/","tags":["windows"],"title":"Win10自启动管理","uri":"/win-self-startup/"},{"categories":["折腾"],"content":"禁止自启动程序 打开任务管理器 在启动一栏中选择指定程序右键禁止其自启动 打开【任务管理器】的方法 CtrlShiftEsc CtrlAltDel -\u003e 任务管理器 WinR -\u003e taskmgr ","date":"2022/01/12","objectID":"/win-self-startup/:1:0","tags":["windows"],"title":"Win10自启动管理","uri":"/win-self-startup/"},{"categories":["折腾"],"content":"添加自启动程序 将需要自启动的程序快捷方式添加到自启动程序文件夹 推荐 可以通过命令启动，WinR -\u003e shell:startup。 C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 编辑注册表，在指定目录下右键新建字符串值 不建议 \\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run \\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce","date":"2022/01/12","objectID":"/win-self-startup/:2:0","tags":["windows"],"title":"Win10自启动管理","uri":"/win-self-startup/"},{"categories":["折腾","示例"],"content":"B站取关脚本分析。","date":"2022/01/07","objectID":"/unscript-bili/","tags":["python"],"title":"B站取关脚本分析","uri":"/unscript-bili/"},{"categories":["折腾","示例"],"content":"需求分析 由于关注UP数量过多不便管理，可把我这个强迫症给急坏了。不如直接取关所有UP，一切从零开始，从头再来，至于还能不能遇见咱们各凭本事。 V1.0 就目前来说，该脚本对路人不友好，使用时需要一定的计算机知识 ","date":"2022/01/07","objectID":"/unscript-bili/:1:0","tags":["python"],"title":"B站取关脚本分析","uri":"/unscript-bili/"},{"categories":["折腾","示例"],"content":"技术分析 获取关注列表 通过GET请求https://api.bilibili.com/x/relation/followings?vmid=xxxxxx header携带数据referer:https://space.bilibili.com/xxxxxx/fans/follow 取关操作 携带数据fid=yyyyyy\u0026act=2\u0026csrf=zzzzzz 发送POST请求https://api.bilibili.com/x/relation/modify ","date":"2022/01/07","objectID":"/unscript-bili/:2:0","tags":["python"],"title":"B站取关脚本分析","uri":"/unscript-bili/"},{"categories":["折腾","示例"],"content":"代码分析 经过抓包分析API接口后得知，取关一个UP只需要进行最多两次HTTP请求，可以通过爬虫进行模拟操作。通过python的requests库既可胜任这个工作，使用简单的requests.get()、requests.post()就行。 在代码基本逻辑理清后，又对B站相关API进行了请求测试，发现完全可行。又考虑到使用的便捷性，决定将变量参数写入config.ini文件中。 [config] # 使用者的B站uid uid = xxxx # 已登录B站的浏览器cookie cookie = yyyy # 跨域请求标识 csrf = zzzz 脚本进行取关操作的前提是知晓该UP的uid，故需要先获取到本人的关注列表数据。 def get_relation(): \"\"\" 获取b站关注列表(每次获取50个) https://api.bilibili.com/x/relation/followings?vmid='UID' :return: 关注up列表（50个） \"\"\" return requests.get(f'https://api.bilibili.com/' f'x/relation/followings?vmid=' f'{config.get(\"config\", \"uid\")}').json()['data']['list'] def unsubscript(up_mid: str): \"\"\" 取关该up https://api.bilibili.com/x/relation/modify 携带数据 :return: 请求状态 \"\"\" header = { 'cookie': config.get('config', 'cookie') } data = { 'fid': up_mid, 'act': 2, 'csrf': config.get('config', 'csrf') } return requests.post( 'https://api.bilibili.com/x/relation/modify', data=data, headers=header).json() ","date":"2022/01/07","objectID":"/unscript-bili/:3:0","tags":["python"],"title":"B站取关脚本分析","uri":"/unscript-bili/"}]