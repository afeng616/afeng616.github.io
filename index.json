[{"categories":["笔记"],"content":"已知弧的中心点、起点和终点，该如何计算该弧的旋转方向？","date":"2024/06/25","objectID":"/arc-dir/","tags":["算法","数学"],"title":"弧方向（顺逆时针）的计算方法","uri":"/arc-dir/"},{"categories":["笔记"],"content":"已知弧的中心点、起点和终点，该如何计算该弧的旋转方向？ 假设一段弧如下图所示，起点为$M$，终点为$N$，中心点为$P$。 通过计算得到两个向量$PM,PN$，再通过$PM\\times PN$叉乘结果进行判断，若结果为正则说明圆弧从M到N为逆时针旋转，否则相反。需要注意此时xy轴正方向分别为右、上，其他情况则需要另外判断。 ","date":"2024/06/25","objectID":"/arc-dir/:0:0","tags":["算法","数学"],"title":"弧方向（顺逆时针）的计算方法","uri":"/arc-dir/"},{"categories":["示例"],"content":"在Win10系统下，使用CMake调用wxWidgets提供的头文件+编译好的二进制dll，并跑通官方文档中的demo。","date":"2023/09/21","objectID":"/use-wxwidgets/","tags":["cpp"],"title":"Windows下通过CMake调用wxWidgets库+Hello World Demo","uri":"/use-wxwidgets/"},{"categories":["示例"],"content":"使用CMake调用wxWidgets库的二进制文件，这种方式并没有在官方的文档中找到，但官方使用文档1还是有很大帮助的。 本机不得已安装了VS，如果不是因为VS Code的一些局限，我可能都不会安装VS，既然已经装了就直接用它的编译环境吧MSVC。开发的时候依然还是想着使用VS Code，所以这里使用CMake编写编译时的一些细节。如果是想着用直接用VS开发可以研读官方文档1尝试一下，也可以跟着我用CMake的方式生成一个VS的obj项目，然后手动点击.sln点击进入。 ","date":"2023/09/21","objectID":"/use-wxwidgets/:0:0","tags":["cpp"],"title":"Windows下通过CMake调用wxWidgets库+Hello World Demo","uri":"/use-wxwidgets/"},{"categories":["示例"],"content":"库文件下载 通过wxWidgets提供的下载网址2下载库头文件、与编译环境对应的二进制文件，点击Download Windows Binaries选择指定文件即可下载。 下载wxWidgets库文件\r下载wxWidgets库文件\r根据本机环境选择需要下载的文件： Header Files（无论什么编译环境都需要下载） dll文件（根据系统编译环境选择下载，本机使用VS2019的编译器） ","date":"2023/09/21","objectID":"/use-wxwidgets/:1:0","tags":["cpp"],"title":"Windows下通过CMake调用wxWidgets库+Hello World Demo","uri":"/use-wxwidgets/"},{"categories":["示例"],"content":"将库引入工程中 根据官方文档1的说明，下载好库文件后需要将它们解压到同一个目录下，并且目录下应只有include文件夹和lib文件夹。 解压wxWidgets库文件\r本机将wxWidgets放在3rdparty目录下。 需要注意的是，要将目录lib/vc14x_x64_dll中vc的版本后缀删除掉，修改为lib/vc_x64_dll，不修改的话后续编译会报错无法找到xx文件（因为查找的目录不对）。 引入wxWidgets库文件\r","date":"2023/09/21","objectID":"/use-wxwidgets/:2:0","tags":["cpp"],"title":"Windows下通过CMake调用wxWidgets库+Hello World Demo","uri":"/use-wxwidgets/"},{"categories":["示例"],"content":"编写Hello Demo 使用官方Demo3即可。 // Start of wxWidgets \"Hello World\" Program #include \u003cwx/wx.h\u003e class MyApp : public wxApp { public: bool OnInit() override; }; wxIMPLEMENT_APP(MyApp); class MyFrame : public wxFrame { public: MyFrame(); private: void OnHello(wxCommandEvent\u0026 event); void OnExit(wxCommandEvent\u0026 event); void OnAbout(wxCommandEvent\u0026 event); }; enum { ID_Hello = 1 }; bool MyApp::OnInit() { MyFrame *frame = new MyFrame(); frame-\u003eShow(true); return true; } MyFrame::MyFrame() : wxFrame(nullptr, wxID_ANY, \"Hello World\") { wxMenu *menuFile = new wxMenu; menuFile-\u003eAppend(ID_Hello, \"\u0026Hello...\\tCtrl-H\", \"Help string shown in status bar for this menu item\"); menuFile-\u003eAppendSeparator(); menuFile-\u003eAppend(wxID_EXIT); wxMenu *menuHelp = new wxMenu; menuHelp-\u003eAppend(wxID_ABOUT); wxMenuBar *menuBar = new wxMenuBar; menuBar-\u003eAppend(menuFile, \"\u0026File\"); menuBar-\u003eAppend(menuHelp, \"\u0026Help\"); SetMenuBar( menuBar ); CreateStatusBar(); SetStatusText(\"Welcome to wxWidgets!\"); Bind(wxEVT_MENU, \u0026MyFrame::OnHello, this, ID_Hello); Bind(wxEVT_MENU, \u0026MyFrame::OnAbout, this, wxID_ABOUT); Bind(wxEVT_MENU, \u0026MyFrame::OnExit, this, wxID_EXIT); } void MyFrame::OnExit(wxCommandEvent\u0026 event) { Close(true); } void MyFrame::OnAbout(wxCommandEvent\u0026 event) { wxMessageBox(\"This is a wxWidgets Hello World example\", \"About Hello World\", wxOK | wxICON_INFORMATION); } void MyFrame::OnHello(wxCommandEvent\u0026 event) { wxLogMessage(\"Hello world from wxWidgets!\"); } ","date":"2023/09/21","objectID":"/use-wxwidgets/:3:0","tags":["cpp"],"title":"Windows下通过CMake调用wxWidgets库+Hello World Demo","uri":"/use-wxwidgets/"},{"categories":["示例"],"content":"编写CMakeLists.txt 因为对C++程序的库依赖还不是很熟，所以折腾了一个下午才搞明白使用wxWidgets库与其他库无异。正常include头文件，如果需要.lib的话link一下。 本机使用官方已经编译好的binaries，所以需要指定.lib文件目录，当然头文件目录也是必须的。为了让.exe运行时查找到所需的dll，可以将.dll目录加入环境变量中，也可以通过.bat临时添加一下环境变量（环境变量只在本次.bat运行时有效）。 为了在链接wxWidgets时寻找到目录，需要设定target_compile_definitions。 由于wxWidgets使用WinMain作为函数入口，所以需要在add_executable时增加WIN324。 cmake_minimum_required(VERSION 3.24.1) project(PCBRouter) # set output path set(INSTALL_PATH ${CMAKE_BINARY_DIR}/../) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${INSTALL_PATH}/bin) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${INSTALL_PATH}/bin) set(LIBRARY_OUTPUT_PATH ${INSTALL_PATH}/lib) # wxWidget3.2.2.1 set(WXWIDGETS_DIR ${CMAKE_SOURCE_DIR}/../3rdparty/wxWidgets) set(WXWIDGETS_DLL_SUFFIX _vc14x_x64) include_directories(${WXWIDGETS_DIR}/include) include_directories(${WXWIDGETS_DIR}/include/msvc) # source file file(GLOB_RECURSE HEADER_FILES *.h*) file(GLOB_RECURSE SOURCE_FILES *.c*) add_executable(PCBRouter WIN32 ${HEADER_FILES} ${SOURCE_FILES}) # set compile mode for using wxWidgets normally target_compile_definitions(PCBRouter PRIVATE WXUSINGDLL=1) target_compile_definitions(PCBRouter PRIVATE _UNICODE=1) target_link_directories(PCBRouter PUBLIC ${WXWIDGETS_DIR}/lib/vc_x64_dll) CMakeLists.txt编写好了以后，简单写一个.bat脚本来方便build项目。 最后一样将直接启动VS加载该项目，我这里不需要使用VS所以就注释掉了。 @echo off rem Please set the build type to desired one, Debug or Release set BUILD_TYPE=Debug rem Default for VS2022, using \"Visual Studio 15 2017 Win64\" if your generator is VS2017 set NMAKE_GENERATOR=\"Visual Studio 16 2019\" set SOURCE_DIR=%~dp0/src set INSTALL_DIR=%~dp0/src_output set TARGET_DIR=%INSTALL_DIR%/obj call cmake --no-warn-unused-cli -DCMAKE_INSTALL_PREFIX:STRING=%INSTALL_DIR% -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -S%SOURCE_DIR% -B%TARGET_DIR% -G %NMAKE_GENERATOR% -T host=x64 -A x64 call cmake --build %TARGET_DIR% --config %BUILD_TYPE% --target ALL_BUILD -j 6 -- @REM call cmake --open %TARGET_DIR% 运行以上这个脚本后，会在工程根目录生成src_output目录，目录下存在文件夹obj和bin分别存储build后的文件和生成的二进制文件。 build后生成的目录\r","date":"2023/09/21","objectID":"/use-wxwidgets/:4:0","tags":["cpp"],"title":"Windows下通过CMake调用wxWidgets库+Hello World Demo","uri":"/use-wxwidgets/"},{"categories":["示例"],"content":"最终效果 到这里整个wxWidgets库的引入已经接近尾声了，但是在运行时会发现不把指定.dll文件copy到.exe文件目录下无法运行，会报错.dll无法找到。针对这个问题上面也说到了两个方法，其实都是针对环境变量的修改，这里我还是比较喜欢通过.bat临时增加环境变量的方式来解决。 如果不想让命令行在.exe运行时持续存在，可以在最后一行前增加start。 @echo off set BUILD_TYPE=Debug set PROJECT_NAME=PCBRouter set INSTALL_DIR=%~dp0/src_output set WXWIDGETS_DIR=%~dp0\\3rdparty\\wxWidgets rem temporarily add wxWidgets LIBS to PATH set PATH=%WXWIDGETS_DIR%\\lib\\vc_x64_dll;%PATH% \"%INSTALL_DIR%/bin/%BUILD_TYPE%/%PROJECT_NAME%.exe\" 程序运行起来后，效果如下： Demo运行效果\r整个项目目录如下： 整体项目目录\rhttps://docs.wxwidgets.org/latest/plat_msw_binaries.html wxWidgets文档: How to use wxMSW binaries ↩︎ ↩︎ ↩︎ https://www.wxwidgets.org/downloads/ wxWidgets下载网址 ↩︎ https://docs.wxwidgets.org/latest/overview_helloworld.html wxWidgets Demo ↩︎ https://www.jarvis73.com/2017/11/06/CMake-Learning/#add_executable 博客: CMake 学习笔记 ↩︎ ","date":"2023/09/21","objectID":"/use-wxwidgets/:5:0","tags":["cpp"],"title":"Windows下通过CMake调用wxWidgets库+Hello World Demo","uri":"/use-wxwidgets/"},{"categories":["折腾"],"content":"windows从零新建一个vue3+electron的项目说明，包括各种环境安装。","date":"2023/08/30","objectID":"/vue3-electron-init/","tags":["javascript"],"title":"windows下vue3+electron的环境搭建","uri":"/vue3-electron-init/"},{"categories":["折腾"],"content":"项目初始化 基于vue3+electron开发桌面应用。 ","date":"2023/08/30","objectID":"/vue3-electron-init/:1:0","tags":["javascript"],"title":"windows下vue3+electron的环境搭建","uri":"/vue3-electron-init/"},{"categories":["折腾"],"content":"环境准备 windows从零新建一个vue3+electron的项目说明，包括各种环境安装。 安装npm npm的安装可以直接使用官方的.exe文件1。 当然也可以使用nvm2进行安装，相比起来更方便，还可以进行npm的版本管理。 nvm安装完毕以后，打开命令行，安装node版本V16（V18版本在安装electron时会有openssl-legacy-provider问题，比较难解决）。 nvm install 16 nvm use 16 安装vue-cli npm install -g @vue/cli 安装electron npm install electron --save-dev 安装过程中可能会遇到下载失败的问题3，解决方法如下： npm config edit 修改.npmrc文件配置并保存。 registry=https://registry.npmmirror.com electron_mirror=https://cdn.npmmirror.com/binaries/electron/ electron_builder_binaries_mirror=https://npmmirror.com/mirrors/electron-builder-binaries/ ","date":"2023/08/30","objectID":"/vue3-electron-init/:1:1","tags":["javascript"],"title":"windows下vue3+electron的环境搭建","uri":"/vue3-electron-init/"},{"categories":["折腾"],"content":"新建架构vue3+electron vue3+electron环境初始化4步骤如下： # 新建vue项目，myproject为项目名称，只能小写 vue create myproject cd myproject # 添加electron vue add electron-builder # 项目启动 npm run electron:serve ","date":"2023/08/30","objectID":"/vue3-electron-init/:1:2","tags":["javascript"],"title":"windows下vue3+electron的环境搭建","uri":"/vue3-electron-init/"},{"categories":["折腾"],"content":"项目共享 当与他人共享源码时，不需要拷贝/node_modules和/dist_electron文件夹以及package-lock.json文件。 由于npm环境不同，很可能导致不必要的错误，它们直接由以下命令生成。 # vue和electron安装完毕后 npm install ","date":"2023/08/30","objectID":"/vue3-electron-init/:2:0","tags":["javascript"],"title":"windows下vue3+electron的环境搭建","uri":"/vue3-electron-init/"},{"categories":["折腾"],"content":"References https://nodejs.org/zh-cn/download “nodejs官方下载网址” ↩︎ https://github.com/coreybutler/nvm-windows/releases “nvm-windows下载网址” ↩︎ https://www.cnblogs.com/makalochen/p/16154510.html “cnblog: npm 安装electron 失败的问题和解决办法” ↩︎ https://segmentfault.com/a/1190000038463122 “segmentfault: Vue+Electron项目简洁快速搭建教程” ↩︎ ","date":"2023/08/30","objectID":"/vue3-electron-init/:3:0","tags":["javascript"],"title":"windows下vue3+electron的环境搭建","uri":"/vue3-electron-init/"},{"categories":null,"content":"\r简单的自我介绍\r什么时间 什么地点 在做什么 2017-2021 五邑大学 电子信息工程，本科 2018-2021 广东省海量生物特征信息处理工程技术研究中心 算法学习 2021 江门市云争科技有限公司 算法工程师实习生 2021-2022 武汉环宇智行科技有限公司 AI算法工程师 2022-now 华中师范大学 计算机科学与技术，硕士 ","date":"2023/07/27","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["示例"],"content":"分别使用静态调用（隐式链接）和动态调用（显式链接）的方式调用dll","date":"2023/07/26","objectID":"/mydll/","tags":["c++"],"title":"DLL调用方式测试","uri":"/mydll/"},{"categories":["示例"],"content":"dll说明 dll（Dynamic Link Library，动态链接库），是一种可以被其它程序调用的程序。 dll文件可以包含代码、数据和资源，允许多个程序同时访问同一个dll文件，这样可以节省内存空间，提高系统性能。 dll的调用方式主要两种，动态调用（显式链接）和静态调用（隐式链接）。 由于调用方式不同，所以在代码编写时有有所不同，但是区别并不大。 可以通过上面的名称看出他们差异1体现在链接阶段。 所需文件如下： 静态调用 动态调用 .h .lib .dll (.h) .dll 在动态调用时，如果导出的只是函数则不需要.h。 如果导出的是一个抽象的功能基类2，则需要这个基类的头文件，具体实现类的头文件不需要。 ","date":"2023/07/26","objectID":"/mydll/:1:0","tags":["c++"],"title":"DLL调用方式测试","uri":"/mydll/"},{"categories":["示例"],"content":"一些细节 首先明确，调用的是动态链接库dll而不是静态链接库lib， 虽然生成dll时同样会存在lib3，但这个文件和前者有明显不同，完全是两码事。 其次，不论是上述哪种调用方式使用dll，程序在运行时都需要用到dll文件。 而lib文件只有使用静态调用的方式在链接阶段需要，动态调用的方式从始至终都不需要lib文件。 一般情况下认为，静态调用需要.h、.lib、.dll，动态调用需要.dll。 dll导出需要使用关键字__declspec(dllexport)标识，一般对它进行宏定义。 dll在设计之初只是为了方便导出函数级的接口，所以最好避免导出变量或类，可能会出现莫名其妙的crash4。 使用动态调用时需要注意，在导出后，编译器会对函数名称进行修改，形如?getInstance@@YA?AV?，可以通过Dependency Walker等工具5查看。 可以通过增加关键字extern \"C\"来避免这种情况，但这样会失去C++的重载功能。 静态调用时，在头部使用#pragma comment(lib, \"xxx.lib\")指定链接的lib文件。 经过测试发现新的一点，如果是使用cmake对项目进行编译，使用target_link_libraries指定链接的lib文件也能达到相同效果。 ","date":"2023/07/26","objectID":"/mydll/:2:0","tags":["c++"],"title":"DLL调用方式测试","uri":"/mydll/"},{"categories":["示例"],"content":"代码示例 // exportclass.h #ifndef __EXPORTCLASS_H__ #define __EXPORTCLASS_H__ #ifndef MYDLL_EXPORTS #define MYDLL_EXPORTS __declspec(dllexport) #else #define MYDLL_EXPORTS __declspec(dllimport) #endif class MYDLL_EXPORTS EX { public: EX(); void test(); }; #endif // __EXPORTCLASS_H__ // exportclass.cpp #include \u003ciostream\u003e #include \"exportclass.h\" EX::EX() {} void EX::test() { std::cout \u003c\u003c \"test\" \u003c\u003c std::endl; } // main.cpp #include \u003ciostream\u003e #include \u003cWindows.h\u003e #include \"module/exportclass.h\" #pragma comment(lib, \"mydll.lib\") // unnecessary while dynamic load void loadDllDyn(std::string funcName) { // Load DLL HMODULE myDLL = LoadLibrary(\"mydll.dll\"); if (myDLL != NULL) { // Get function pointer typedef EX (*GetInstanceFunc)(); GetInstanceFunc getInstance = (GetInstanceFunc)GetProcAddress(myDLL, funcName.c_str()); if (getInstance == NULL) { std::cout \u003c\u003c \"Error: getInstance function not found\" \u003c\u003c std::endl; } else { // Call function EX ex = getInstance(); ex.test(); } // Unload DLL FreeLibrary(myDLL); } else { std::cout \u003c\u003c \"Error: no dll be found\" \u003c\u003c std::endl; } } int main() { try { // dynamic load loadDllDyn(\"??0EX@@QEAA@XZ\"); // static load EX ex; ex.test(); } catch(const char* msg) { std::cout \u003c\u003c msg \u003c\u003c std::endl; } std::cout \u003c\u003c \"exit\" \u003c\u003c std::endl; return 0; } 为了偷懒，上面的例子中直接导出了整个实现类，并没有使用导出抽象基类或导出函数的方式，这点在编写代码时可优化。 ","date":"2023/07/26","objectID":"/mydll/:3:0","tags":["c++"],"title":"DLL调用方式测试","uri":"/mydll/"},{"categories":["示例"],"content":"参考资料 https://www.cnblogs.com/xiangtingshen/p/10979419.html “博客园: 动态链接库dll的静态加载与动态加载” ↩︎ https://blog.csdn.net/qiangzi4646/article/details/79628260 “CSDN: dll导出类比较好的方式” ↩︎ https://blog.csdn.net/qq_29007291/article/details/113439343 “CSDN: windows visual studio生成dll总是伴随着lib” ↩︎ https://club.topsage.com/thread-497586-1-1.html “论坛: DLL导出类避免地狱问题的完美解决方案” ↩︎ https://github.com/JelinYao/dependency “GitHub: dependency” ↩︎ ","date":"2023/07/26","objectID":"/mydll/:4:0","tags":["c++"],"title":"DLL调用方式测试","uri":"/mydll/"},{"categories":["笔记"],"content":"一些coding、论文、优化算法、强化学习、深度学习的知识。","date":"2023/07/16","objectID":"/research/","tags":["research"],"title":"论文那些事儿","uri":"/research/"},{"categories":["笔记"],"content":"基础知识 Base Softmax和Sigmoid，详解1 2 小结\r都可用于多分类问题中，Sigmoid函数常用于有多个正确答案的分类问题，Softmax函数常用于有一个正确答案的分类问题。\rtanh，详解3 torch.gather函数详解4，见汤胤评论 ","date":"2023/07/16","objectID":"/research/:1:0","tags":["research"],"title":"论文那些事儿","uri":"/research/"},{"categories":["笔记"],"content":"深度学习 Deep Learning LSTM，详解5 6 小结\rLSTM通过门控状态来控制传输状态，忘记+选择性记忆=输出。\rGRU，详解7，论文8 小结\rGRU效果与LSTM相近，减少了计算量。\rAttention，详解9，视频10 11 Transformer，详解12 ","date":"2023/07/16","objectID":"/research/:2:0","tags":["research"],"title":"论文那些事儿","uri":"/research/"},{"categories":["笔记"],"content":"强化学习 Reinforcement Learning SARSA，详解13 Q-Learning，详解14 小结\rDQN，详解15 ","date":"2023/07/16","objectID":"/research/:3:0","tags":["research"],"title":"论文那些事儿","uri":"/research/"},{"categories":["笔记"],"content":"参考资料 Reference https://www.jianshu.com/p/037bf733713f “简书: 分类问题中Sigmoid与Softmax区别” ↩︎ https://devpress.csdn.net/xian/64a6246db1e197348be16c6a.html “论坛: 三分钟认知Softmax和Sigmoid的详细区别” ↩︎ https://www.jianshu.com/p/7409c8f1cdca “简书: 神经网络中的激活函数-tanh” ↩︎ https://zhuanlan.zhihu.com/p/352877584 “知乎: 图解PyTorch中的torch.gather函数” ↩︎ https://zhuanlan.zhihu.com/p/32085405 “知乎: 人人都能看懂的LSTM” ↩︎ https://zhuanlan.zhihu.com/p/42717426 “知乎: 详解LSTM” ↩︎ https://zhuanlan.zhihu.com/p/32481747 “知乎: 人人都能看懂的GRU” ↩︎ https://arxiv.org/pdf/1412.3555.pdf “论文: Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling” ↩︎ https://zhuanlan.zhihu.com/p/46313756 “知乎: Attention机制简单总结” ↩︎ https://www.bilibili.com/video/BV1q3411U7Hi “Bili: Attention、Transformer公式推导和矩阵变化” ↩︎ https://zhuanlan.zhihu.com/p/46313756 “知乎: Attention机制简单总结” ↩︎ https://zhuanlan.zhihu.com/p/166608727 “知乎: 举个例子讲下transformer的输入输出细节及其他” ↩︎ ./RL/common_alg/SARSA.md “文档: SARSA” ↩︎ ./RL/common_alg/Q-Learning.md “文档: Q-Learning” ↩︎ https://paddlepedia.readthedocs.io/en/latest/tutorials/reinforcement_learning/DQN.html “文档: DQN” ↩︎ ","date":"2023/07/16","objectID":"/research/:4:0","tags":["research"],"title":"论文那些事儿","uri":"/research/"},{"categories":["示例"],"content":"Pytorch测试GPU是否可用。","date":"2023/06/03","objectID":"/pytorch-gpu-test/","tags":["python"],"title":"Pytorch测试GPU是否可用","uri":"/pytorch-gpu-test/"},{"categories":["示例"],"content":"pytorch分为cpu和gpu两个版本，若需要验证gpu版本是否安装成功可以通过以下命令 import torch # 返回当前设备索引 torch.cuda.current_device() # 返回gpu数量 torch.cuda.device_count() # 返回gpu名称，索引从0开始 torch.cuda.get_device_name(0) # cuda是否可用 torch.cuda.is_available() ","date":"2023/06/03","objectID":"/pytorch-gpu-test/:0:0","tags":["python"],"title":"Pytorch测试GPU是否可用","uri":"/pytorch-gpu-test/"},{"categories":["杂谈"],"content":"关于近日使用京东读书APP的一些体验感受。","date":"2023/05/27","objectID":"/jd_reader/","tags":[],"title":"关于近日使用京东读书APP的一些体验感受","uri":"/jd_reader/"},{"categories":["杂谈"],"content":"前几天jd会员要到期了，想买点小东西没有运费券嫖了，就想着再续个会员， 无意间看了一下jd plus的会员权益，发现里面权益还真不少啊。 比起前些年来说，现在的权益涉及方方面面，其他的就不多说了，毕竟不是来打广告的。 没多久我在角落里发现了一个京东读书的权益，毕竟上了研究生以来爱上了看书。 简单使用了一下，APP功能肯定和其他的无异，毕竟读书APP嘛，也没啥花活可以整， 同时也很明显的感受到，这个APP应该尚在起步阶段，很多微信读书APP的功能它都没有。 主要值得吐槽的一点是，APP内部的书籍资源主要还是以售卖为主，本来猜测开通会员后可以在有效期内查看这些书籍的， 后来发现然并卵。会员免费的书籍资源是独立出来的，也就是说开了会员，这个会员库里的书籍对于会员来说是免费的， 不在这个库里的书，该收费还是要收费，对于购书来说倒是一个不小的便利。（还好只是1￥开了7天会员试试水，验证自己的猜想。） 但对于想白嫖看书来说，显然是不太可能的了。 值得一提的是，京东读书内部也有一个导入书籍的功能，等微信读书上传的免费数量（200本）用完以后，再去体验一下吧。 就现在而言，还是先用着微信读书吧，毕竟每天看一会儿书就能白嫖体验卡，能看更多的书，无论是从体验还是心理感受来看都是更香的。 ","date":"2023/05/27","objectID":"/jd_reader/:0:0","tags":[],"title":"关于近日使用京东读书APP的一些体验感受","uri":"/jd_reader/"},{"categories":["折腾","示例"],"content":"将第三方手柄输出映射到鼠标上。","date":"2023/05/21","objectID":"/diy-gamepad/","tags":["python"],"title":"将第三方手柄输出映射到鼠标上","uri":"/diy-gamepad/"},{"categories":["折腾","示例"],"content":"说明 将游戏手柄的摇杆映射为鼠标滚轮操作， 当前只是将向上和向下操作映射为鼠标滚轮的上下滚动。 通过pynput库完全可以更大程度的映射手柄操作， 鼠标指针移动 鼠标点击 键盘快捷键 … 更多pynpug库接口，可参看官方文档1。 ","date":"2023/05/21","objectID":"/diy-gamepad/:1:0","tags":["python"],"title":"将第三方手柄输出映射到鼠标上","uri":"/diy-gamepad/"},{"categories":["折腾","示例"],"content":"全部代码 # @auth: afeng # @desc: get gamepad input and output mouse cmd # @date: 2023/05/21 import pygame from pynput.mouse import Controller pygame.init() clock = pygame.time.Clock() pygame.joystick.init() mouse = Controller() scroll_offset = .2 # gamepad joystick = pygame.joystick.Joystick(0) joystick.init() name = joystick.get_name() print(f\"Joystick name: {name}\".format(name)) while True: for event in pygame.event.get(): # User did something pass # if event.type == pygame.QUIT: # If user clicked close # done=True # Flag that we are done so we exit this loop axes = joystick.get_numaxes() for i in range( axes ): if i==0 or i==3: continue axis = joystick.get_axis( i ) # Axis 0: -1 left, 1 right # Axis 1: -1 up, 1 down # Axis 2: -1 up, 1 down # Axis 3: -1 left, 1 right # mouse scroll dy: -1 down, 1 up mouse.scroll(0, -i*axis*scroll_offset) clock.tick(20) https://pynput.readthedocs.io/en/latest/ “pynput库官方文档” ↩︎ ","date":"2023/05/21","objectID":"/diy-gamepad/:2:0","tags":["python"],"title":"将第三方手柄输出映射到鼠标上","uri":"/diy-gamepad/"},{"categories":["笔记"],"content":"混合牛顿法。","date":"2023/05/14","objectID":"/newton_hybrid/","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"综述 所谓混合牛顿法1是指结合牛顿法和梯度下降法的特点，若牛顿方向可行，则使用牛顿法进行迭代，若不行，则使用梯度下降法确定搜索方向。 具体搜索方向选取的逻辑可以是这样的： $$ \\begin{align} \u0026if\\ \\nabla^2 f(x_k)正定,则\\quad d_k=-\\nabla^2f(x_k)^{-1}\\nabla f(x_k)\\\\ \u0026if\\ \\nabla^2f(x_k)负定,则\\quad d_k=\\nabla^2f(x_k)^{-1}\\nabla f(x_k)\\\\ \u0026else\\ \\quad\\quad d_k=-\\nabla f(x_k) \\end{align} $$ ","date":"2023/05/14","objectID":"/newton_hybrid/:1:0","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"细节说明 ","date":"2023/05/14","objectID":"/newton_hybrid/:2:0","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"Hessian矩阵 关于Hessian矩阵（$\\nabla^2 f(x_k)$）的正定性说明2。 简单地说，如果Hessian矩阵正定，则 函数的二阶偏导数恒 \u003e 0 函数的变化率（斜率）即一阶导数始终处于递增状态 函数为凸 ","date":"2023/05/14","objectID":"/newton_hybrid/:2:1","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"牛顿法 牛顿法求解方程近似解 若求解$f(x)=0$在$\\mathbb R$上的解$x^*$，通过选取迭代初值$x_0$，使用牛顿迭代公式逼近$x^*$。 $$ x_{t+1}=x_t-\\frac{f(x_t)}{f'(x_t)} $$ 将​$f(x)$在迭代初值$x_0$​处Taylor展开可得： $$ f(x)=f(x_0)+f'(x_0)(x-x_0)+o(|x-x_0|) $$ 舍去高阶项，可得： $$ f(x)=f(x_0)+f'(x_0)(x-x_0) $$ 将零点$x^*$代入可得： $$ f(x^*)=0=f(x_0)+f'(x_0)(x^*-x_0) \\\\ x^*=x_0-\\frac{f(x_0)}{f'(x_0)} $$ 由于上式是舍去了高阶项后的近似，因此我们实际上并不能根据上式一步得到$x^*$​。而要通过多步迭代，由此得到牛顿迭代方程： $$ x_{t+1}=x_t-\\frac{f(x_t)}{f'(x_{t})} $$ 牛顿法在最优化上的应用 对于一阶可微的函数​$f:\\mathbb R\\to\\mathbb R$ ，根据费马定理，其极值点$x^*$​满足$f'(x^*)=0$，而最优化方法的目的也就是通过种种手段，求出或近似这个极值点$x^*$。注意到牛顿法是用来求解函数$g(x)$​的一个零点的近似值​$\\hat x$的，而最优化则是求解导数的零点的近似解，那么令$g(x)=f'(x)$​，迭代出来的​$\\hat x$不就是极值点$x^*$​的近似解了吗？ 因此，使用牛顿法优化函数$f$的迭代方程也就呼之欲出了： $$ x_{t+1}=x_t-\\frac{g(x_t)}{g'(x_t)}=x_t-\\frac{f'(x_t)}{f''(x_t)}=x_t-f''(x_t)^{-1}f'(x_t) $$ 当然，这需要​$f$是二阶可导的，此处就默许我们研究的函数足够正定。 上述为一维输入的情形，对于​$f:\\mathbb R^n\\to\\mathbb R$也有类似的迭代式： $$ x_{t+1}=x_t-\\nabla^2f(x_t)^{-1}\\nabla f(x_t)\\quad\\quad x_t\\in\\mathbb R^n\\ $$ 其证明方法和一维情形几乎一致。 牛顿法优化函数算法过程 牛顿法优化函数的算法： $$ \\begin{align} 选定\u0026迭代初值x_0\\in\\Omega,选取\\epsilon\u003e0,重复以下操作:\\\\ \u0026若||\\nabla f(x_t)||\u003c\\epsilon，停止循环\\\\ \u0026计算梯度:\\nabla f(x_t)\\\\ \u0026计算Hessian矩阵:\\nabla^2f(x_t)\\\\ \u0026计算方向:d_t=-\\nabla^2f(x_t)^{-1}\\nabla f(x_t)\\\\ \u0026更新迭代点:x_{t+1}=x_t-d\\\\ \\end{align} $$ ","date":"2023/05/14","objectID":"/newton_hybrid/:2:2","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"与梯度下降法比较 牛顿法： $$ x_{t+1}=x_t-\\nabla^2f(x_t)^{-1}\\nabla f(x_t) $$ 梯度下降法： $$ x_{t+1}=x_t-\\gamma\\nabla f(x_t) $$ 可以发现，这两个方法都是基于当前迭代点的梯度信息进行搜索方向的选择的，只不过梯队下降法是在梯度的反方向上进行线搜得到下一个迭代点，而牛顿法则是通过Hessian矩阵在梯度上进行线性变换得到搜索方向（甚至步长都不需要确定）。 所以牛顿法对函数在迭代点处的信息利用更加充分，直观来看，相比于梯度下降法，函数足够正则的情况下牛顿法迭代得更加准确，收敛速率也会更快。 所有基于梯度的迭代方程可以写成如下的形式： $$ x_{t+1}=x_t-H(x_t)\\nabla f(x_t) $$ 其中$x\\in\\mathbb R^n,H(x_t)\\in\\mathbb R^{n\\times n}$。 对于牛顿法来说，$H(x_t)=\\nabla^2f(x_t)^{-1}$ 对于梯度下降法来说，$H(x_t)=\\gamma I$ 可以看到，牛顿法$H$的​是随着当前迭代点的变化动态变化的，因此，相比于梯度下降法，牛顿法具有更加灵活的迭代过程。有的书上直接说牛顿法就是“自适应的梯度下降法”。 ","date":"2023/05/14","objectID":"/newton_hybrid/:2:3","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["笔记"],"content":"参考 https://zhuanlan.zhihu.com/p/293951317 “知乎: 最优化方法复习笔记（三）牛顿法及其收敛性分析” ↩︎ https://blog.csdn.net/qq_39521554/article/details/78895869 “CSDN: Hessian矩阵正定与函数凹凸性的关系” ↩︎ ","date":"2023/05/14","objectID":"/newton_hybrid/:3:0","tags":["算法","数学"],"title":"混合牛顿法","uri":"/newton_hybrid/"},{"categories":["示例"],"content":"md渲染测试","date":"2023/05/12","objectID":"/blog-test/","tags":["markdown"],"title":"Blog Test","uri":"/blog-test/"},{"categories":["示例"],"content":"事件发展 ","date":"2023/05/12","objectID":"/blog-test/:1:0","tags":["markdown"],"title":"Blog Test","uri":"/blog-test/"},{"categories":["示例"],"content":"content This is a test blog. This is my first blog at GitHub Page website! This is a test blog. This is my first blog at GitHub Page website! This is a test blog. This is my first blog at GitHub Page website! This is a test blog. This is my first blog at GitHub Page website! This is a test blog. This is my first blog at GitHub Page website! ","date":"2023/05/12","objectID":"/blog-test/:2:0","tags":["markdown"],"title":"Blog Test","uri":"/blog-test/"},{"categories":["示例"],"content":"数学公式 $$ \\begin{aligned} Q_(n+1)\u0026=\\frac{1}{n}\\sum_{i=1}^nR_i \\\\\\\\ \u0026=Q_n+\\frac{1}{n}(R_n-Q_n) \\end{aligned} $$ $$ \\begin{aligned} Q_(n+1)\u0026=\\frac{1}{n}\\sum_{i=1}^nR_i \\\\ \u0026=Q_n+\\frac{1}{n}(R_n-Q_n) \\end{aligned} $$ ","date":"2023/05/12","objectID":"/blog-test/:3:0","tags":["markdown"],"title":"Blog Test","uri":"/blog-test/"},{"categories":["示例"],"content":"参考 GitHub: Github Pages + Hugo 搭建个人博客 少数派: Hugo + GitHub Action，搭建你的博客自动发布系统 ","date":"2023/05/12","objectID":"/blog-test/:4:0","tags":["markdown"],"title":"Blog Test","uri":"/blog-test/"},{"categories":["折腾","示例"],"content":"快手取关脚本。","date":"2022/04/04","objectID":"/kuaishou-unsubscript/","tags":["javascript"],"title":"快手取关脚本","uri":"/kuaishou-unsubscript/"},{"categories":["折腾","示例"],"content":"简单的元素筛选，模拟点击即可！ ","date":"2022/04/04","objectID":"/kuaishou-unsubscript/:0:0","tags":["javascript"],"title":"快手取关脚本","uri":"/kuaishou-unsubscript/"},{"categories":["折腾","示例"],"content":"代码 let num = 0 for (let tmp of document.getElementsByClassName('container')){ tmp.children[2].children[0].click() console.log('取关', ++num) } ","date":"2022/04/04","objectID":"/kuaishou-unsubscript/:1:0","tags":["javascript"],"title":"快手取关脚本","uri":"/kuaishou-unsubscript/"},{"categories":["折腾","示例"],"content":"使用方法 进入快手网页版个人页面-\u003e关注一栏，如https://www.kuaishou.com/profile/kuaishou_id，多次按下CtrlEnd组合键使页面滚动到最下端（方便一次运行完毕），F12打开开发者工具，输入上述命令运行即可。 ","date":"2022/04/04","objectID":"/kuaishou-unsubscript/:2:0","tags":["javascript"],"title":"快手取关脚本","uri":"/kuaishou-unsubscript/"},{"categories":["折腾","示例"],"content":"Twitter取关脚本。","date":"2022/04/03","objectID":"/twitter-unsubscript/","tags":["javascript"],"title":"Twitter取关脚本","uri":"/twitter-unsubscript/"},{"categories":["折腾","示例"],"content":"由于Twitter页面显示情况较特殊，暂时没有找到更高效的批量取关方法。 ","date":"2022/04/03","objectID":"/twitter-unsubscript/:0:0","tags":["javascript"],"title":"Twitter取关脚本","uri":"/twitter-unsubscript/"},{"categories":["折腾","示例"],"content":"代码 let btns = document.querySelectorAll(\"[data-testid]\") let followBtns = Array.from(btns).filter(btn =\u003e { return btn.getAttribute('data-testid').includes('unfollow') }) for (let i = 1; i \u003c= followBtns.length; i++) { followBtns[i - 1].click(); let _span = document.getElementsByTagName('span'); for (var j = 0; j \u003c _span.length; j++) { if (_span[j].textContent == \"取消关注\") { _span[j].click(); console.log(\"取关\"); } } } ","date":"2022/04/03","objectID":"/twitter-unsubscript/:1:0","tags":["javascript"],"title":"Twitter取关脚本","uri":"/twitter-unsubscript/"},{"categories":["折腾","示例"],"content":"使用说明 使用网页版Twitter进入个人资料-\u003e正在关注页面，网址例如https://twitter.com/xxxxx/following。 F12调出开发者工具，在console栏中输入上述代码。每次运行能取关几十人，多运行几次就行。 ","date":"2022/04/03","objectID":"/twitter-unsubscript/:2:0","tags":["javascript"],"title":"Twitter取关脚本","uri":"/twitter-unsubscript/"},{"categories":["折腾"],"content":"删除设备和驱动器中的图标。","date":"2022/04/01","objectID":"/delete-win-driver-logo/","tags":["windows"],"title":"删除设备和驱动器中的图标","uri":"/delete-win-driver-logo/"},{"categories":["折腾"],"content":"说明 情况是这样的 设备和驱动器多余图标\r","date":"2022/04/01","objectID":"/delete-win-driver-logo/:1:0","tags":["windows"],"title":"删除设备和驱动器中的图标","uri":"/delete-win-driver-logo/"},{"categories":["折腾"],"content":"操作 主要操作如下： 打开注册表（WINR键入regedit） 搜索路径 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\ 删除不需要的图标项 修改注册表\r","date":"2022/04/01","objectID":"/delete-win-driver-logo/:2:0","tags":["windows"],"title":"删除设备和驱动器中的图标","uri":"/delete-win-driver-logo/"},{"categories":["笔记"],"content":"计算机网络参考模型。","date":"2022/03/15","objectID":"/computer-network-osi/","tags":["计算机网络"],"title":"计算机网络参考模型","uri":"/computer-network-osi/"},{"categories":["笔记"],"content":"OSI和TCP/IP标准 ","date":"2022/03/15","objectID":"/computer-network-osi/:1:0","tags":["计算机网络"],"title":"计算机网络参考模型","uri":"/computer-network-osi/"},{"categories":["笔记"],"content":"综合标准 经过综合考量当前认定的标准是五层结构 分层单位协议应用层报文FTP、SMTP、HTTP传输层报文段TCP、UDP网络层数据报IP、ICMP、OSPF数据链路层帧PPP、Ethernet物理层比特","date":"2022/03/15","objectID":"/computer-network-osi/:2:0","tags":["计算机网络"],"title":"计算机网络参考模型","uri":"/computer-network-osi/"},{"categories":["折腾"],"content":"CentOS7重装python以及yum。","date":"2022/02/17","objectID":"/centos-reinstall-sth/","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"没事千万别拿环境开玩笑！ ​——沃兹基·硕德 轻易不要尝试 轻易不要尝试 轻易不要尝试 由于之前使用的python版本过低，无法使用很多模块的新特性。然而在尝试更新python版本时遇到了很多坑，不仅把原python3更新为新版本后，原yum不能用了，而且pip也无法正常工作。且卸载python3老版本的时候不小心吧python2给卸载了，yum又需要python2。几番尝试之后无果，干脆全部重装算了！ ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:0:0","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"卸载原python、yum 卸载现有python（所有版本及模块）。 rpm -qa|grep python|xargs rpm -ev --allmatches --nodeps ##强制删除已安装程序及其关联 whereis python |xargs rm -frv ##删除所有残余文件 ##xargs，允许你对输出执行其他某些命令 whereis python ##验证删除，返回无结果 卸载现有yum。 rpm -qa|grep yum|xargs rpm -ev --allmatches --nodeps whereis yum |xargs rm -frv ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:1:0","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装python2 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:2:0","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装python2.7.15 使用python.org下载太慢，这里使用淘宝镜像下载。 https://registry.npmmirror.com/-/binary/python/2.7.15/Python-2.7.15.tgz cd /usr/local/src wget https://registry.npmmirror.com/-/binary/python/2.7.15/Python-2.7.15.tgz tar -zxvf Python-2.7.15.tgz cd Python-2.7.15 ./configure make \u0026\u0026 make install 创建软链接，将python2.7.15版本命名为python2，将python留给python3版本使用。 ln /usr/local/bin/python /usr/local/bin/python2 将涉及/usr/bin/python的设置更新为/usr/bin/python2，毕竟python2.7的软链接已经被改成了python2。 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:2:1","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装pip 查找网上的教程都是通过以下yum命令安装的，然而我却总是显示没有匹配包，我也是挺无奈的。 yum -y install python-pip 干脆就直接使用源码安装算了，反正也不复杂。 # 1.下载python-pip包 wget https://pypi.python.org/packages/source/p/pip/pip-1.3.1.tar.gz --no-check-certificate # 2.安装pip之前需要先安装setuptools wget https://pypi.python.org/packages/2.7/s/setuptools/setuptools-0.6c11-py2.7.egg --no-check-certificate chmod +x setuptools-0.6c11-py2.7.egg sh setuptools-0.6c11-py2.7.egg # 3.安装pip chmod +x pip-1.3.1.tar.gz tar xzvf pip-1.3.1.tar.gz cd pip-1.3.1 python setup.py install 可以愉快的使用pip了。 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:2:2","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装yum 据说yum的使用需要用到python2，具体我也没有细究，反正至少先安装好python2就行了。 以下链接与CentOS版本相关，具体链接可在网易镜像中依照具体系统查找。 cat /etc/centos-release # 查看系统版本号 # CentOS Linux release 7.6.1810 (Core) ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:3:0","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"下载相关文件 wget http://mirrors.163.com/centos/7/os/x86_64/Packages/python-urlgrabber-3.10-8.el7.noarch.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/python-iniparse-0.4-9.el7.noarch.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-45.el7.noarch.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-3.4.3-158.el7.centos.noarch.rpm ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:3:1","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"按照顺序安装 rpm -ivh python-iniparse-0.4-9.el7.noarch.rpm rpm -ivh python-urlgrabber-3.10-8.el7.noarch.rpm rpm -ivh yum-3.4.3-158.el7.centos.noarch.rpm yum-metadata-parser-1.1.4-10.el7.x86_64.rpm yum-plugin-fastestmirror-1.1.31-45.el7.noarch.rpm 注意：yum和yum-plugin-xxx一定要同时安装，因为他们彼此依赖，先安装谁都会报错。 安装中途很可能会出现依赖错误导致安装失败，如python(abi) = 2.7 is needed by xxx。 该错误则需要安装以下几个包： python-libs-2.7.5-68.el7.x86_64.rpm python-2.7.5-68.el7.x86_64.rpm python-devel-2.7.5-68.el7.x86_64.rpm 注意：在安装时仍然会遇到依赖错误，那么安装提示在网易镜像中查找对应版本文件，使用wget下载后安装即可。 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:3:2","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"修改yum源 在使用yum安装时出现http404之类的错误，很有可能就是yum源有问题。 # 1.进入系统yum源目录 cd /etc/yum.repos.d # 2.备份原来的yum源 mkdir bak \u0026\u0026 mv *.repo bak # 3.下载yum源 wget http://mirrors.163.com/.help/CentOS7-Base-163.repo # 4.改名成默认repo mv CentOS7-Base-163.repo CentOS-Base.repo # 5.生成缓存，是配置生效 yum makecache # 6.验证配置源 yum repolist # 查看是否有163的标识 # 7.更新yum文件 yum update -y 接下来就可以正常使用yum了。 注意：修改时可能遇到/usr/bin/applydeltarpm not installed的情况 缺什么安装什么就完事了！ yum provides '*/applydeltarpm' yum install deltarpm -y ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:3:3","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装python3 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:4:0","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"安装python3.8 现在使用python开发基本都是使用python3了，自然不能少。python不能装太老的，因为以后可能官方就不支持了，也不能太新，因为还不稳定，资料也不够多，所以综合考虑python3.8就差不多了。 cd /usr/local/src wget https://registry.npmmirror.com/-/binary/python/3.8.8/Python-3.8.8.tgz tar -zxvf Python-3.8.8.tgz cd Python-3.8.8 ./configure make \u0026\u0026 make install ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:4:1","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"修改python3为默认 安装后通过python3就能使用该版本，不过一般都习惯只键入python，所以在这里创建软链接即可 which python3 # 查看python3位置 # /usr/local/bin/python3 ln /usr/local/bin/python3 /usr/local/bin/python # 创建软链接 python -V # 查看版本 # Python 3.8.8 ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:4:2","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"配置pip3 python3.8安装成功后，pip3就已经安装完毕了！键入pip3就能正常使用，如果想将它设为默认的话，可以修改软链接。当然这一步其实可以不配置 which pip # 查看原pip # /usr/local/bin/pip mv /usr/local/bin/pip /usr/local/bin/pip_bak # 备份 which pip3 # 查看pip3位置 # /usr/local/bin/pip3 ln /usr/local/bin/pip3 /usr/local/bin/pip # 创建软链接 pip -V 查看当前pip版本 pip 20.2.3 from /usr/local/lib/python3.8/site-packages/pip (python 3.8) 完事！还是python3安装最简单。 至此终于把整个重装工作完成了！ 网上的资料真是太坑了，要么不详细，要么根本就是直接偷别人的。fo了！ ","date":"2022/02/17","objectID":"/centos-reinstall-sth/:4:3","tags":["linux","环境"],"title":"重装CentOS环境","uri":"/centos-reinstall-sth/"},{"categories":["折腾"],"content":"远程开机的实现分析。","date":"2022/01/25","objectID":"/remote-wol/","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"这次开发的需求很简单，就是想使用移动端通过互联网实现对主机的开机、关机、休眠、睡眠以及重启的控制。 明确了需求后就开始构思解决方案，在此过程中，通过互联网了解到市场上存在能完成该任务的产品。于是我就开始对其中的HiPC[1]进行了了解，发现该产品由软件端（小程序及pc端应用）和硬件端（类似二次开发的网卡）组成，再结合搜索到的资料，我大致了解整个过程的实现思路。 ","date":"2022/01/25","objectID":"/remote-wol/:0:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"HiPC的实现思路 该实现思路为本人摸索得出，仅供参考，侵权删！ 下载并使用HiPC的PC端应用程序后不难发现，仅使用该程序就可以配合小程序经过互联网完成对PC的远程关机、休眠、睡眠以及重启控制，而想使用开机功能（无论通过局域网还是广域网）则需要购买其硬件产品。将焦点放在PC端程序还发现，若想完成上述操作，该程序还必须在PC上正常运行。 ","date":"2022/01/25","objectID":"/remote-wol/:1:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"除开机外其他控制的实现 经过简单的分析发现，此应用与云服务器建立了WebSocket连接，使得该应用能够将PC的实时状态上传至服务器，同时使小程序能及时更新PC数据，并完成对PC的操作控制。 HiPC.exe后台监控PC状态，并通过WebSocket传输数据给服务器小程序发送指令至服务器，服务器通过WebSocket将指令转发给HiPC.exe使其执行相应指令 ![HiPC实现逻辑][hipc-process] 通过以上的方式使得用户能脱离局域网完成对PC除开机以外的其他控制。 ","date":"2022/01/25","objectID":"/remote-wol/:1:1","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"开机功能的实现 开机功能实质是唤醒PC，在PC进入关机、休眠、睡眠状态下，系统中原有的运行程序将停止正常工作。因此，无法再通过上述的逻辑实现远程唤醒操作。 这时候再将关注点放在硬件设备上，即HiPC售卖的PCI-E设备。经过简单分析，初步判断该设备为经过特定编程开发的网卡，实质通过WoL[2]完成对主机的唤醒。使用WoL需要有两个前提：1.主板支持；2.网卡支持。实现简单的局域网唤醒[3]满足以上两个条件经过简单设置就能实现，简单的原理就是处在同一局域网内的某设备向目标PC的网卡地址发送UDP数据包，网卡接收到指定格式数据后通过主板唤醒主机。 本地唤醒\r然而想完成远程唤醒，还需要满足一个较苛刻的条件，即实现外网向内网指定网卡发包。绝大部分家庭使用的网络IP都是动态的，大部分家庭网络IP更是经过多层路由转发，因此其网关WAN IP都有可能是内网IP，而内网对于外网而言是透明的。由此，实现精准发包就需要下一点功夫了，这也是HiPC配合硬件端完成的工作。 在已经实现局域网内开机功能后，经过了几天的探索，最终确立了能够实现远程控制的方案。 ","date":"2022/01/25","objectID":"/remote-wol/:1:2","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"方案 局域网实现对PC的控制 需要：主板支持；网卡支持； 局域网开机可以根据WoL网络唤醒实现其他操作完全可以下载HiPC.exe完成广域网实现对PC的控制 需要：主板支持；网卡支持；路由器支持；服务器；公网IP； 依照WoL原理，从服务器发送udp数据包，经过互联网传输到有公网IP的网关WAN口，通过端口映射进入内网，通过路由器将数据包转发给指定网卡 远程唤醒\r其他操作依赖HiPC.exe对于除开机外的其他操作，虽然可以完全手写，但个人觉得完全没必要。 ","date":"2022/01/25","objectID":"/remote-wol/:2:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"远程开机实现细节 该实现细节建立在方案1完成的前提下，依照【局域网使用WoL网络唤醒】可完成方案1实施 依照上述方案2实现通过互联网远程唤醒主机，需要考虑的问题如下： Q：为什么不使用花生壳做内网穿透？ A：在进行方案尝试时，是存在使用花生壳的想法的，但是在具体实施时发现了问题：计算机需要保持花生壳客户端的运行才能使内网穿透正常，对于待唤醒的PC，这点自然无法满足。个人认为花生壳适合用于搭建服务器，使用户能通过互联网访问到本地服务器资源，与本需求相悖，同时也确实没有必要。在路由器上使用花生壳提供的DDNS服务时，总是会有莫名的错误导致无法达到预期效果，最终放弃了这个方案。 Q：为什么要进行网关和路由器的端口映射？ A：本需求只要求某PC网卡能接收到来自公网的数据包。拥有公网IP的WAN口可以直接收到来自互联网的数据包，这时对网关进行端口映射使指定外部端口映射到内网某IP的端口，使得来自公网的数据能够被内网的设备接收到。若目标PC与网关间存在其他路由器，则相应路由器中也应该做好端口映射，以保证目标设备能接收到转发的数据包。 Q：即便申请到了公网IP，家庭用网的公网IP是动态的，如何确保发包目的地址为目标PC网卡？ A：网络运营商虽然可以接受个人申请使用公网IP，但是非专线（固定公网IP）的用户使用的公网IP是动态的。由于同一网关下的所有连接设备都共用一个公网IP，所以一开始设想让目标PC定时发送公网IP给服务器供其更新。随后觉得这个想法不合理，如果公网IP在PC未启动时更新，奈何？所以想到使用移动端代替原设想中PC的功能。移动设备设置自动化任务，通过指定API获取最新的公网IP发送至服务器供其更新。 ","date":"2022/01/25","objectID":"/remote-wol/:3:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"总结 在网卡和主板支持的前提下，基本可以无压力的实现局域网内的开机控制。而仅使用HiPC开发的应用程序就能实现远程（通过互联网也可）控制PC关机、休眠、重启等操作。若在不购置开机卡的前提下想通过互联网完成开机控制，就多少需要花些心思了。 ","date":"2022/01/25","objectID":"/remote-wol/:4:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["折腾"],"content":"References HiPC \"HiPC官网\" ↩︎ Wake on Lan原理 \"向指定网卡发送指定格式的UDP数据包\" ↩︎ 局域网使用WoL网络唤醒 \"局域网某设备向目标PC网卡发送WoL包\" ↩︎ ","date":"2022/01/25","objectID":"/remote-wol/:5:0","tags":[],"title":"远程开机的实现分析","uri":"/remote-wol/"},{"categories":["示例"],"content":"Clipboard.js使用实例。","date":"2022/01/13","objectID":"/demo-clipboardjs/","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"说明 通过Clipboard.js可以完成对指定元素原格式内容的复制功能。 使用时需要注意以下两点： 新建Clipboard对象时，指定触发对象 触发对象最好使用\u003cbutton\u003e元素 ","date":"2022/01/13","objectID":"/demo-clipboardjs/:1:0","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"代码说明 ","date":"2022/01/13","objectID":"/demo-clipboardjs/:2:0","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"动态添加复制按钮 在网页指定位置添加触发器，即按钮（使用了JQuery，也可通过JavaScript原生代码编写） // 添加复制按钮 $('.toolbar').append('\u003cbutton class=\"button copy-button\"\u003e\u003cspan\u003eCopy\u003c/span\u003e\u003c/button\u003e'); ","date":"2022/01/13","objectID":"/demo-clipboardjs/:2:1","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"动态指定复制目标 可以在不修改html的情况下，通过编辑js代码完成创建Clipboard对象，并添加触发器 // 创建Clipboard对象并完成初始化 var copyCode = new Clipboard('.copy-button', { target: function (trigger) { return trigger.parentElement.previousElementSibling; } }); ","date":"2022/01/13","objectID":"/demo-clipboardjs/:2:2","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"编写回调函数 // Clipboard对象的回调函数（复制成功，复制失败） copyCode.on('success', function (event) { event.clearSelection(); event.trigger.textContent = 'Copied'; window.setTimeout(function () { event.trigger.textContent = 'Copy'; }, 2000); }); copyCode.on('error', function (event) { event.trigger.textContent = 'Error'; window.setTimeout(function () { event.trigger.textContent = 'Copy'; }, 2000); }); ","date":"2022/01/13","objectID":"/demo-clipboardjs/:2:3","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["示例"],"content":"完整代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eClipboard.js使用实例\u003c/title\u003e \u003cstyle\u003e .button { display: inline-block; height: auto; border-radius: 5px; padding: 3px 8px; border: 2px solid rgb(8, 230, 238); } .container { display: inline-block; height: auto; padding: 10px 15px; border: 3px dotted greenyellow; border-radius: 5px; } \u003c/style\u003e \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.4.0/clipboard.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv style=\"text-align: center;\"\u003e \u003cdiv class=\"container\"\u003e \u003ccode\u003eClipboard\u003c/code\u003e \u003cdiv class=\"toolbar\"\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"container\"\u003e \u003ccode\u003e使用\u003c/code\u003e \u003cdiv class=\"toolbar\"\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"container\"\u003e \u003ccode\u003e实例\u003c/code\u003e \u003cdiv class=\"toolbar\"\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript\u003e $('.toolbar').append('\u003cbutton class=\"button copy-button\"\u003e\u003cspan\u003eCopy\u003c/span\u003e\u003c/button\u003e'); var copyCode = new Clipboard('.copy-button', { target: function (trigger) { return trigger.parentElement.previousElementSibling; } }); copyCode.on('success', function (event) { event.clearSelection(); event.trigger.textContent = 'Copied'; window.setTimeout(function () { event.trigger.textContent = 'Copy'; }, 2000); }); copyCode.on('error', function (event) { event.trigger.textContent = 'Error'; window.setTimeout(function () { event.trigger.textContent = 'Copy'; }, 2000); }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022/01/13","objectID":"/demo-clipboardjs/:3:0","tags":["javascript"],"title":"Clipboard.js使用实例","uri":"/demo-clipboardjs/"},{"categories":["折腾"],"content":"Win10自启动管理。","date":"2022/01/12","objectID":"/win-self-startup/","tags":["windows"],"title":"Win10自启动管理","uri":"/win-self-startup/"},{"categories":["折腾"],"content":"禁止自启动程序 打开任务管理器 在启动一栏中选择指定程序右键禁止其自启动 打开【任务管理器】的方法 CtrlShiftEsc CtrlAltDel -\u003e 任务管理器 WinR -\u003e taskmgr ","date":"2022/01/12","objectID":"/win-self-startup/:1:0","tags":["windows"],"title":"Win10自启动管理","uri":"/win-self-startup/"},{"categories":["折腾"],"content":"添加自启动程序 将需要自启动的程序快捷方式添加到自启动程序文件夹 推荐 可以通过命令启动，WinR -\u003e shell:startup。 C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 编辑注册表，在指定目录下右键新建字符串值 不建议 \\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run \\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce ","date":"2022/01/12","objectID":"/win-self-startup/:2:0","tags":["windows"],"title":"Win10自启动管理","uri":"/win-self-startup/"},{"categories":["折腾","示例"],"content":"B站取关脚本分析。","date":"2022/01/07","objectID":"/unscript-bili/","tags":["python"],"title":"B站取关脚本分析","uri":"/unscript-bili/"},{"categories":["折腾","示例"],"content":"需求分析 由于关注UP数量过多不便管理，可把我这个强迫症给急坏了。不如直接取关所有UP，一切从零开始，从头再来，至于还能不能遇见咱们各凭本事。 V1.0 就目前来说，该脚本对路人不友好，使用时需要一定的计算机知识 ","date":"2022/01/07","objectID":"/unscript-bili/:1:0","tags":["python"],"title":"B站取关脚本分析","uri":"/unscript-bili/"},{"categories":["折腾","示例"],"content":"技术分析 获取关注列表 通过GET请求https://api.bilibili.com/x/relation/followings?vmid=xxxxxx header携带数据referer:https://space.bilibili.com/xxxxxx/fans/follow 取关操作 携带数据fid=yyyyyy\u0026act=2\u0026csrf=zzzzzz 发送POST请求https://api.bilibili.com/x/relation/modify ","date":"2022/01/07","objectID":"/unscript-bili/:2:0","tags":["python"],"title":"B站取关脚本分析","uri":"/unscript-bili/"},{"categories":["折腾","示例"],"content":"代码分析 经过抓包分析API接口后得知，取关一个UP只需要进行最多两次HTTP请求，可以通过爬虫进行模拟操作。通过python的requests库既可胜任这个工作，使用简单的requests.get()、requests.post()就行。 在代码基本逻辑理清后，又对B站相关API进行了请求测试，发现完全可行。又考虑到使用的便捷性，决定将变量参数写入config.ini文件中。 [config] # 使用者的B站uid uid = xxxx # 已登录B站的浏览器cookie cookie = yyyy # 跨域请求标识 csrf = zzzz 脚本进行取关操作的前提是知晓该UP的uid，故需要先获取到本人的关注列表数据。 def get_relation(): \"\"\" 获取b站关注列表(每次获取50个) https://api.bilibili.com/x/relation/followings?vmid='UID' :return: 关注up列表（50个） \"\"\" return requests.get(f'https://api.bilibili.com/' f'x/relation/followings?vmid=' f'{config.get(\"config\", \"uid\")}').json()['data']['list'] def unsubscript(up_mid: str): \"\"\" 取关该up https://api.bilibili.com/x/relation/modify 携带数据 :return: 请求状态 \"\"\" header = { 'cookie': config.get('config', 'cookie') } data = { 'fid': up_mid, 'act': 2, 'csrf': config.get('config', 'csrf') } return requests.post( 'https://api.bilibili.com/x/relation/modify', data=data, headers=header).json() ","date":"2022/01/07","objectID":"/unscript-bili/:3:0","tags":["python"],"title":"B站取关脚本分析","uri":"/unscript-bili/"}]